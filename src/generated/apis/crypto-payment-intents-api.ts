/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setBearerAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError
} from "../base";
// @ts-ignore
import { BadRequest } from "../models";
// @ts-ignore
import { CreateCryptoRefundResponse } from "../models";
// @ts-ignore
import { CreatePaymentIntentRequest } from "../models";
// @ts-ignore
import { CreatePaymentIntentResponse } from "../models";
// @ts-ignore
import { CryptoRefundCreationRequest } from "../models";
// @ts-ignore
import { ExpirePaymentIntentResponse } from "../models";
// @ts-ignore
import { Forbidden } from "../models";
// @ts-ignore
import { GetPaymentIntentResponse } from "../models";
// @ts-ignore
import { ListPaymentIntentsResponse } from "../models";
// @ts-ignore
import { NotAuthorized } from "../models";
// @ts-ignore
import { NotFound } from "../models";
/**
 * CryptoPaymentIntentsApi - axios parameter creator
 * @export
 */
export const CryptoPaymentIntentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a transient or continuous payment intent
     * @summary Create a payment intent
     * @param {CreatePaymentIntentRequest} [createPaymentIntentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentIntent: async (
      createPaymentIntentRequest?: CreatePaymentIntentRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/paymentIntents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentIntentRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Expire a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    expirePaymentIntent: async (
      id: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("expirePaymentIntent", "id", id);
      const localVarPath = `/v1/paymentIntents/{id}/expire`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentIntent: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getPaymentIntent", "id", id);
      const localVarPath = `/v1/paymentIntents/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List all payment intents
     * @param {'created' | 'pending' | 'complete' | 'expired' | 'failed'} [status] Filters by the most recent &#x60;timeline.status&#x60; within the payment intent.
     * @param {'underpaid' | 'paid' | 'overpaid'} [context] Filters by the most recent &#x60;timeline.context&#x60; within the payment intent.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentIntents: async (
      status?: "created" | "pending" | "complete" | "expired" | "failed",
      context?: "underpaid" | "paid" | "overpaid",
      from?: string,
      to?: string,
      pageBefore?: string,
      pageAfter?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/paymentIntents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (context !== undefined) {
        localVarQueryParameter["context"] = context;
      }

      if (from !== undefined) {
        localVarQueryParameter["from"] =
          (from as any) instanceof Date ? (from as any).toISOString() : from;
      }

      if (to !== undefined) {
        localVarQueryParameter["to"] =
          (to as any) instanceof Date ? (to as any).toISOString() : to;
      }

      if (pageBefore !== undefined) {
        localVarQueryParameter["pageBefore"] = pageBefore;
      }

      if (pageAfter !== undefined) {
        localVarQueryParameter["pageAfter"] = pageAfter;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Refund a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CryptoRefundCreationRequest} [cryptoRefundCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundPaymentIntent: async (
      id: string,
      cryptoRefundCreationRequest?: CryptoRefundCreationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("refundPaymentIntent", "id", id);
      const localVarPath = `/v1/paymentIntents/{id}/refund`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cryptoRefundCreationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * CryptoPaymentIntentsApi - functional programming interface
 * @export
 */
export const CryptoPaymentIntentsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    CryptoPaymentIntentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a transient or continuous payment intent
     * @summary Create a payment intent
     * @param {CreatePaymentIntentRequest} [createPaymentIntentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentIntent(
      createPaymentIntentRequest?: CreatePaymentIntentRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreatePaymentIntentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPaymentIntent(
          createPaymentIntentRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Expire a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async expirePaymentIntent(
      id: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpirePaymentIntentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.expirePaymentIntent(id, body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentIntent(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetPaymentIntentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPaymentIntent(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary List all payment intents
     * @param {'created' | 'pending' | 'complete' | 'expired' | 'failed'} [status] Filters by the most recent &#x60;timeline.status&#x60; within the payment intent.
     * @param {'underpaid' | 'paid' | 'overpaid'} [context] Filters by the most recent &#x60;timeline.context&#x60; within the payment intent.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentIntents(
      status?: "created" | "pending" | "complete" | "expired" | "failed",
      context?: "underpaid" | "paid" | "overpaid",
      from?: string,
      to?: string,
      pageBefore?: string,
      pageAfter?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListPaymentIntentsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listPaymentIntents(
          status,
          context,
          from,
          to,
          pageBefore,
          pageAfter,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Refund a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CryptoRefundCreationRequest} [cryptoRefundCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refundPaymentIntent(
      id: string,
      cryptoRefundCreationRequest?: CryptoRefundCreationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateCryptoRefundResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.refundPaymentIntent(
          id,
          cryptoRefundCreationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    }
  };
};

/**
 * CryptoPaymentIntentsApi - factory interface
 * @export
 */
export const CryptoPaymentIntentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CryptoPaymentIntentsApiFp(configuration);
  return {
    /**
     * Create a transient or continuous payment intent
     * @summary Create a payment intent
     * @param {CreatePaymentIntentRequest} [createPaymentIntentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentIntent(
      createPaymentIntentRequest?: CreatePaymentIntentRequest,
      options?: any
    ): AxiosPromise<CreatePaymentIntentResponse> {
      return localVarFp
        .createPaymentIntent(createPaymentIntentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Expire a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    expirePaymentIntent(
      id: string,
      body?: object,
      options?: any
    ): AxiosPromise<ExpirePaymentIntentResponse> {
      return localVarFp
        .expirePaymentIntent(id, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentIntent(
      id: string,
      options?: any
    ): AxiosPromise<GetPaymentIntentResponse> {
      return localVarFp
        .getPaymentIntent(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all payment intents
     * @param {'created' | 'pending' | 'complete' | 'expired' | 'failed'} [status] Filters by the most recent &#x60;timeline.status&#x60; within the payment intent.
     * @param {'underpaid' | 'paid' | 'overpaid'} [context] Filters by the most recent &#x60;timeline.context&#x60; within the payment intent.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentIntents(
      status?: "created" | "pending" | "complete" | "expired" | "failed",
      context?: "underpaid" | "paid" | "overpaid",
      from?: string,
      to?: string,
      pageBefore?: string,
      pageAfter?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<ListPaymentIntentsResponse> {
      return localVarFp
        .listPaymentIntents(
          status,
          context,
          from,
          to,
          pageBefore,
          pageAfter,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Refund a payment intent
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CryptoRefundCreationRequest} [cryptoRefundCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundPaymentIntent(
      id: string,
      cryptoRefundCreationRequest?: CryptoRefundCreationRequest,
      options?: any
    ): AxiosPromise<CreateCryptoRefundResponse> {
      return localVarFp
        .refundPaymentIntent(id, cryptoRefundCreationRequest, options)
        .then((request) => request(axios, basePath));
    }
  };
};

/**
 * CryptoPaymentIntentsApi - object-oriented interface
 * @export
 * @class CryptoPaymentIntentsApi
 * @extends {BaseAPI}
 */
export class CryptoPaymentIntentsApi extends BaseAPI {
  /**
   * Create a transient or continuous payment intent
   * @summary Create a payment intent
   * @param {CreatePaymentIntentRequest} [createPaymentIntentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CryptoPaymentIntentsApi
   */
  public createPaymentIntent(
    createPaymentIntentRequest?: CreatePaymentIntentRequest,
    options?: AxiosRequestConfig
  ) {
    return CryptoPaymentIntentsApiFp(this.configuration)
      .createPaymentIntent(createPaymentIntentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Expire a payment intent
   * @param {string} id Universally unique identifier (UUID v4) of a resource.
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CryptoPaymentIntentsApi
   */
  public expirePaymentIntent(
    id: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return CryptoPaymentIntentsApiFp(this.configuration)
      .expirePaymentIntent(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a payment intent
   * @param {string} id Universally unique identifier (UUID v4) of a resource.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CryptoPaymentIntentsApi
   */
  public getPaymentIntent(id: string, options?: AxiosRequestConfig) {
    return CryptoPaymentIntentsApiFp(this.configuration)
      .getPaymentIntent(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all payment intents
   * @param {'created' | 'pending' | 'complete' | 'expired' | 'failed'} [status] Filters by the most recent &#x60;timeline.status&#x60; within the payment intent.
   * @param {'underpaid' | 'paid' | 'overpaid'} [context] Filters by the most recent &#x60;timeline.context&#x60; within the payment intent.
   * @param {string} [from] Queries items created since the specified date-time (inclusive).
   * @param {string} [to] Queries items created before the specified date-time (inclusive).
   * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
   * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
   * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CryptoPaymentIntentsApi
   */
  public listPaymentIntents(
    status?: "created" | "pending" | "complete" | "expired" | "failed",
    context?: "underpaid" | "paid" | "overpaid",
    from?: string,
    to?: string,
    pageBefore?: string,
    pageAfter?: string,
    pageSize?: number,
    options?: AxiosRequestConfig
  ) {
    return CryptoPaymentIntentsApiFp(this.configuration)
      .listPaymentIntents(
        status,
        context,
        from,
        to,
        pageBefore,
        pageAfter,
        pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Refund a payment intent
   * @param {string} id Universally unique identifier (UUID v4) of a resource.
   * @param {CryptoRefundCreationRequest} [cryptoRefundCreationRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CryptoPaymentIntentsApi
   */
  public refundPaymentIntent(
    id: string,
    cryptoRefundCreationRequest?: CryptoRefundCreationRequest,
    options?: AxiosRequestConfig
  ) {
    return CryptoPaymentIntentsApiFp(this.configuration)
      .refundPaymentIntent(id, cryptoRefundCreationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
