/* tslint:disable */
/* eslint-disable */
/**
 * Core Functionality
 * APIs for managing your account balance. These endpoints are available with all Circle APIs.
 *
 * The version of the OpenAPI document: ${version}
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ACH
 */
export interface ACH {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof ACH
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof ACH
     */
    'status'?: ExternalFiatAccountStatus;
    /**
     * The redacted account number of the ACH account.
     * @type {string}
     * @memberof ACH
     */
    'accountNumber': string;
    /**
     * The routing number of the ACH account.
     * @type {string}
     * @memberof ACH
     */
    'routingNumber': string;
    /**
     * 
     * @type {ACHBillingDetails}
     * @memberof ACH
     */
    'billingDetails': ACHBillingDetails;
    /**
     * 
     * @type {BankAddress}
     * @memberof ACH
     */
    'bankAddress': BankAddress;
    /**
     * A UUID that uniquely identifies the account number. If the same account is used more than once, each card object will have a different id, but the fingerprint will stay the same.
     * @type {string}
     * @memberof ACH
     */
    'fingerprint': string;
    /**
     * 
     * @type {AchVerificationErrorCodes}
     * @memberof ACH
     */
    'errorCode'?: AchVerificationErrorCodes | null;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof ACH
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof ACH
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof ACH
     */
    'updateDate': string;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof ACH
     */
    'metadata': MetadataPhoneEmail;
}
/**
 * Billing details of the account holder.
 * @export
 * @interface ACHBillingDetails
 */
export interface ACHBillingDetails {
    /**
     * Full name of the card or bank account holder.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'name': string;
    /**
     * City portion of the address.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'city'?: string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'country'?: string;
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'line1'?: string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'line2'?: string;
    /**
     * State / County / Province / Region portion of the address. If the country is US or Canada, then district is required and should use the two-letter code for the subdivision.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'district'?: string;
    /**
     * Postal / ZIP code of the address.
     * @type {string}
     * @memberof ACHBillingDetails
     */
    'postalCode'?: string;
}
/**
 * 
 * @export
 * @interface ACHCreationRequest
 */
export interface ACHCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof ACHCreationRequest
     */
    'idempotencyKey': string;
    /**
     * The token for the ACH account provided by the processor (Plaid).
     * @type {string}
     * @memberof ACHCreationRequest
     */
    'plaidProcessorToken': string;
    /**
     * 
     * @type {ACHBillingDetails}
     * @memberof ACHCreationRequest
     */
    'billingDetails': ACHBillingDetails;
    /**
     * 
     * @type {MetadataCardAndAch}
     * @memberof ACHCreationRequest
     */
    'metadata': MetadataCardAndAch;
}
/**
 * 
 * @export
 * @interface AccountConfiguration
 */
export interface AccountConfiguration {
    /**
     * 
     * @type {AccountConfigurationPayments}
     * @memberof AccountConfiguration
     */
    'payments'?: AccountConfigurationPayments;
}
/**
 * 
 * @export
 * @interface AccountConfigurationPayments
 */
export interface AccountConfigurationPayments {
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof AccountConfigurationPayments
     */
    'masterWalletId'?: string;
}
/**
 * Indicates the failure reason of the ACH account. Only present on failed accounts. Possible values are [bank_account_authorization_expired, bank_account_error, bank_account_ineligible, bank_account_not_found, bank_account_unauthorized, unsupported_routing_number, verification_failed].
 * @export
 * @enum {string}
 */

export const AchVerificationErrorCodes = {
    BankAccountAuthorizationExpired: 'bank_account_authorization_expired',
    BankAccountError: 'bank_account_error',
    BankAccountIneligible: 'bank_account_ineligible',
    BankAccountNotFound: 'bank_account_not_found',
    BankAccountUnauthorized: 'bank_account_unauthorized',
    UnsupportedRoutingNumber: 'unsupported_routing_number',
    VerificationFailed: 'verification_failed'
} as const;

export type AchVerificationErrorCodes = typeof AchVerificationErrorCodes[keyof typeof AchVerificationErrorCodes];


/**
 * 
 * @export
 * @interface AddressObject
 */
export interface AddressObject {
    /**
     * An alphanumeric string representing a blockchain address. Will be in different formats for different chains. It is important to preserve the exact formatting and capitalization of the address.
     * @type {string}
     * @memberof AddressObject
     */
    'address'?: string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof AddressObject
     */
    'addressTag'?: string | null;
    /**
     * 
     * @type {Currency}
     * @memberof AddressObject
     */
    'currency'?: Currency | null;
    /**
     * 
     * @type {Chain}
     * @memberof AddressObject
     */
    'chain'?: Chain;
}
/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * 
     * @type {number}
     * @memberof BadRequest
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof BadRequest
     */
    'message': string;
}
/**
 * Available and unsettled balances of the merchant.
 * @export
 * @interface Balances
 */
export interface Balances {
    /**
     * List of currency balances (one for each currency) that are currently available to spend.
     * @type {Array<Money>}
     * @memberof Balances
     */
    'available': Array<Money>;
    /**
     * List of currency balances (one for each currency) that have been captured but are currently in the process of settling and will become available to spend at some point in the future.
     * @type {Array<Money>}
     * @memberof Balances
     */
    'unsettled': Array<Money>;
}
/**
 * The address details for the bank, as provided during bank account creation.
 * @export
 * @interface BankAddress
 */
export interface BankAddress {
    /**
     * Name of the bank. This property is required for bank accounts outside of the US that do not support IBAN\'
     * @type {string}
     * @memberof BankAddress
     */
    'bankName'?: string;
    /**
     * City portion of the address. This property is required for bank accounts outside of the US.
     * @type {string}
     * @memberof BankAddress
     */
    'city'?: string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof BankAddress
     */
    'country': string;
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof BankAddress
     */
    'line1'?: string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof BankAddress
     */
    'line2'?: string;
    /**
     * State / County / Province / Region portion of the address. US and Canada use the two-letter code for the subdivision.
     * @type {string}
     * @memberof BankAddress
     */
    'district'?: string;
}
/**
 * The address of the bank. City and country fields are required.
 * @export
 * @interface BankAddressIbanSupported
 */
export interface BankAddressIbanSupported {
    /**
     * Name of the bank. This property is required for bank accounts outside of the US that do not support IBAN\'
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'bankName'?: string;
    /**
     * City portion of the address. This property is required for bank accounts outside of the US.
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'city': string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'country': string;
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'line1'?: string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'line2'?: string;
    /**
     * State / County / Province / Region portion of the address. US and Canada use the two-letter code for the subdivision.
     * @type {string}
     * @memberof BankAddressIbanSupported
     */
    'district'?: string;
}
/**
 * The address of the bank. BankName, City and Country fields are required.
 * @export
 * @interface BankAddressNonIban
 */
export interface BankAddressNonIban {
    /**
     * Name of the bank. This property is required for bank accounts outside of the US that do not support IBAN\'
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'bankName': string;
    /**
     * City portion of the address. This property is required for bank accounts outside of the US.
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'city': string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'country': string;
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'line1'?: string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'line2'?: string;
    /**
     * State / County / Province / Region portion of the address. US and Canada use the two-letter code for the subdivision.
     * @type {string}
     * @memberof BankAddressNonIban
     */
    'district'?: string;
}
/**
 * The destination bank account.
 * @export
 * @interface BankDestination
 */
export interface BankDestination {
    /**
     * 
     * @type {PayoutDestinationType}
     * @memberof BankDestination
     */
    'type': PayoutDestinationType;
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BankDestination
     */
    'id': string;
    /**
     * Bank name plus last four digits of the bank account number or IBAN.
     * @type {string}
     * @memberof BankDestination
     */
    'name'?: string;
}
/**
 * Status information of the related cancel. This property is only present on canceled payment or refund items.
 * @export
 * @interface BasicCancel
 */
export interface BasicCancel {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BasicCancel
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof BasicCancel
     */
    'type': BasicCancelTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof BasicCancel
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof BasicCancel
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicCancel
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof BasicCancel
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof BasicCancel
     */
    'description'?: BasicCancelDescriptionEnum;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof BasicCancel
     */
    'status': CancelRefundReversalStatus;
    /**
     * 
     * @type {PaymentInfoPaymentAndRefund}
     * @memberof BasicCancel
     */
    'originalPayment'?: PaymentInfoPaymentAndRefund;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicCancel
     */
    'fees'?: FiatMoneyUsd;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof BasicCancel
     */
    'channel'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicCancel
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicCancel
     */
    'updateDate'?: string;
}

export const BasicCancelTypeEnum = {
    Cancel: 'cancel'
} as const;

export type BasicCancelTypeEnum = typeof BasicCancelTypeEnum[keyof typeof BasicCancelTypeEnum];
export const BasicCancelDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type BasicCancelDescriptionEnum = typeof BasicCancelDescriptionEnum[keyof typeof BasicCancelDescriptionEnum];

/**
 * 
 * @export
 * @interface BasicChargeback
 */
export interface BasicChargeback {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BasicChargeback
     */
    'id': string;
    /**
     * Unique system generated identifier for the payment that is associated to the chargeback item.
     * @type {string}
     * @memberof BasicChargeback
     */
    'paymentId': string;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof BasicChargeback
     */
    'merchantId': string;
    /**
     * Reason code given by the card network for the chargeback item.
     * @type {string}
     * @memberof BasicChargeback
     */
    'reasonCode': string;
    /**
     * 
     * @type {ChargebackCategories}
     * @memberof BasicChargeback
     */
    'category'?: ChargebackCategories;
    /**
     * The chargeback item\'s history list will be sorted by create date descending: more recent chargeback statuses will be at the beginning of the list. 
     * @type {Array<BasicChargebackHistory>}
     * @memberof BasicChargeback
     */
    'history': Array<BasicChargebackHistory>;
}
/**
 * 
 * @export
 * @interface BasicChargebackHistory
 */
export interface BasicChargebackHistory {
    /**
     * Enumerated type of the chargeback history event. `1st Chargeback` represents the first stage of the dispute procedure initiated by the cardholder’s issuing bank.   `2nd Chargeback` represents the second stage of the dispute procedure initiated by the cardholder’s issuing bank (This stage is MasterCard only).   `Chargeback Reversal` represents when 1st Chargeback or 2nd Chargeback is withdrawn by the issuer.   `Representment` represents the stage when merchants decided to dispute 1st Chargeback or 2nd Chargeback.   `Chargeback Settlement` can imply one of the two: 1) If merchant or marketplace is taking the lost of the chargeback, money will be debit from the wallet during this stage.   2) If merchant of marketplace successfully dispute the chargeback, money will be credit back to the wallet during this stage. 
     * @type {string}
     * @memberof BasicChargebackHistory
     */
    'type': BasicChargebackHistoryTypeEnum;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicChargebackHistory
     */
    'chargebackAmount': FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicChargebackHistory
     */
    'fee'?: FiatMoneyUsd;
    /**
     * The reason the chargeback was created.
     * @type {string}
     * @memberof BasicChargebackHistory
     */
    'description': string;
    /**
     * Unique system generated identifier for the settlement related to the chargeback history.
     * @type {string}
     * @memberof BasicChargebackHistory
     */
    'settlementId'?: string | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicChargebackHistory
     */
    'createDate'?: string;
}

export const BasicChargebackHistoryTypeEnum = {
    _1stChargeback: '1st Chargeback',
    _2ndChargeback: '2nd Chargeback',
    ChargebackReversal: 'Chargeback Reversal',
    Representment: 'Representment',
    ChargebackSettlement: 'Chargeback Settlement'
} as const;

export type BasicChargebackHistoryTypeEnum = typeof BasicChargebackHistoryTypeEnum[keyof typeof BasicChargebackHistoryTypeEnum];

/**
 * Status information of the related payment. This property is only present on refund or cancel items.
 * @export
 * @interface BasicPayment
 */
export interface BasicPayment {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BasicPayment
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof BasicPayment
     */
    'type': BasicPaymentTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof BasicPayment
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof BasicPayment
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicPayment
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof BasicPayment
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof BasicPayment
     */
    'description'?: BasicPaymentDescriptionEnum;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof BasicPayment
     */
    'status': PaymentStatus;
    /**
     * Determines if a payment has successfully been captured. This property is only present for payments that did not use auto capture.
     * @type {boolean}
     * @memberof BasicPayment
     */
    'captured'?: boolean;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicPayment
     */
    'captureAmount'?: FiatMoneyUsd;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicPayment
     */
    'captureDate'?: string;
    /**
     * 
     * @type {RequiredAction}
     * @memberof BasicPayment
     */
    'requiredAction'?: RequiredAction;
    /**
     * 
     * @type {PaymentInfoCancel}
     * @memberof BasicPayment
     */
    'cancel'?: PaymentInfoCancel | null;
    /**
     * 
     * @type {Array<PaymentInfoPaymentAndRefund>}
     * @memberof BasicPayment
     */
    'refunds'?: Array<PaymentInfoPaymentAndRefund>;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicPayment
     */
    'fees'?: FiatMoneyUsd;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof BasicPayment
     */
    'channel'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicPayment
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicPayment
     */
    'updateDate'?: string;
}

export const BasicPaymentTypeEnum = {
    Payment: 'payment'
} as const;

export type BasicPaymentTypeEnum = typeof BasicPaymentTypeEnum[keyof typeof BasicPaymentTypeEnum];
export const BasicPaymentDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type BasicPaymentDescriptionEnum = typeof BasicPaymentDescriptionEnum[keyof typeof BasicPaymentDescriptionEnum];

/**
 * 
 * @export
 * @interface BasicRefund
 */
export interface BasicRefund {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BasicRefund
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof BasicRefund
     */
    'type': BasicRefundTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof BasicRefund
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof BasicRefund
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicRefund
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof BasicRefund
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof BasicRefund
     */
    'description'?: BasicRefundDescriptionEnum;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof BasicRefund
     */
    'status': CancelRefundReversalStatus;
    /**
     * 
     * @type {PaymentInfoPaymentAndRefund}
     * @memberof BasicRefund
     */
    'originalPayment'?: PaymentInfoPaymentAndRefund;
    /**
     * 
     * @type {PaymentInfoCancel}
     * @memberof BasicRefund
     */
    'cancel'?: PaymentInfoCancel | null;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BasicRefund
     */
    'fees'?: FiatMoneyUsd;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof BasicRefund
     */
    'channel'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicRefund
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BasicRefund
     */
    'updateDate'?: string;
}

export const BasicRefundTypeEnum = {
    Refund: 'refund'
} as const;

export type BasicRefundTypeEnum = typeof BasicRefundTypeEnum[keyof typeof BasicRefundTypeEnum];
export const BasicRefundDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type BasicRefundDescriptionEnum = typeof BasicRefundDescriptionEnum[keyof typeof BasicRefundDescriptionEnum];

/**
 * 
 * @export
 * @interface BillingDetails
 */
export interface BillingDetails {
    /**
     * Full name of the card or bank account holder.
     * @type {string}
     * @memberof BillingDetails
     */
    'name': string;
    /**
     * City portion of the address.
     * @type {string}
     * @memberof BillingDetails
     */
    'city': string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof BillingDetails
     */
    'country': string;
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof BillingDetails
     */
    'line1': string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof BillingDetails
     */
    'line2'?: string;
    /**
     * State / County / Province / Region portion of the address. If the country is US or Canada, then district is required and should use the two-letter code for the subdivision.
     * @type {string}
     * @memberof BillingDetails
     */
    'district'?: string;
    /**
     * Postal / ZIP code of the address.
     * @type {string}
     * @memberof BillingDetails
     */
    'postalCode': string;
}
/**
 * A deposit
 * @export
 * @interface BusinessAccountDeposit
 */
export interface BusinessAccountDeposit {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BusinessAccountDeposit
     */
    'id': string;
    /**
     * The identifier for the bank account where the funds were deposited from.
     * @type {string}
     * @memberof BusinessAccountDeposit
     */
    'sourceWalletId'?: string;
    /**
     * 
     * @type {WalletLocation}
     * @memberof BusinessAccountDeposit
     */
    'destination': WalletLocation;
    /**
     * 
     * @type {FiatMoney}
     * @memberof BusinessAccountDeposit
     */
    'amount': FiatMoney;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof BusinessAccountDeposit
     */
    'fee'?: FiatMoneyUsd;
    /**
     * Status of the deposit. Status `pending` indicates that the deposit is in the process of running; `complete` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof BusinessAccountDeposit
     */
    'status': BusinessAccountDepositStatusEnum;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof BusinessAccountDeposit
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BusinessAccountDeposit
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof BusinessAccountDeposit
     */
    'updateDate'?: string;
}

export const BusinessAccountDepositStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type BusinessAccountDepositStatusEnum = typeof BusinessAccountDepositStatusEnum[keyof typeof BusinessAccountDepositStatusEnum];

/**
 * The destination bank account.
 * @export
 * @interface BusinessAccountDestinationRequest
 */
export interface BusinessAccountDestinationRequest {
    /**
     * 
     * @type {string}
     * @memberof BusinessAccountDestinationRequest
     */
    'type': BusinessAccountDestinationRequestTypeEnum;
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BusinessAccountDestinationRequest
     */
    'id': string;
}

export const BusinessAccountDestinationRequestTypeEnum = {
    Wire: 'wire',
    Sen: 'sen'
} as const;

export type BusinessAccountDestinationRequestTypeEnum = typeof BusinessAccountDestinationRequestTypeEnum[keyof typeof BusinessAccountDestinationRequestTypeEnum];

/**
 * 
 * @export
 * @interface BusinessAccountGenerateAddressRequest
 */
export interface BusinessAccountGenerateAddressRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof BusinessAccountGenerateAddressRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Currency}
     * @memberof BusinessAccountGenerateAddressRequest
     */
    'currency': Currency | null;
    /**
     * 
     * @type {Chain}
     * @memberof BusinessAccountGenerateAddressRequest
     */
    'chain': Chain;
}
/**
 * 
 * @export
 * @interface BusinessAccountPayoutCreationRequest
 */
export interface BusinessAccountPayoutCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof BusinessAccountPayoutCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {BusinessAccountDestinationRequest}
     * @memberof BusinessAccountPayoutCreationRequest
     */
    'destination': BusinessAccountDestinationRequest;
    /**
     * 
     * @type {FiatMoney}
     * @memberof BusinessAccountPayoutCreationRequest
     */
    'amount': FiatMoney;
}
/**
 * Adds a recipient address. The currency parameter will default to USD for all chains except for BTC where it defaults to BTC.
 * @export
 * @interface BusinessAccountRecipientAddressCreationRequest
 */
export interface BusinessAccountRecipientAddressCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'idempotencyKey': string;
    /**
     * An alphanumeric string representing a blockchain address. Will be in different formats for different chains. It is important to preserve the exact formatting and capitalization of the address.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'address': string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'addressTag'?: string | null;
    /**
     * 
     * @type {Chain}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'chain': Chain;
    /**
     * 
     * @type {Currency}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'currency'?: Currency | null;
    /**
     * An identifier or sentence that describes the recipient.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressCreationRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface BusinessAccountRecipientAddressObject
 */
export interface BusinessAccountRecipientAddressObject {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'id'?: string;
    /**
     * An alphanumeric string representing a blockchain address. Will be in different formats for different chains. It is important to preserve the exact formatting and capitalization of the address.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'address'?: string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'addressTag'?: string | null;
    /**
     * 
     * @type {Chain}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'chain'?: Chain;
    /**
     * 
     * @type {Currency}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'currency'?: Currency | null;
    /**
     * An identifier or sentence that describes the recipient.
     * @type {string}
     * @memberof BusinessAccountRecipientAddressObject
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface BusinessAccountTransferCreationRequest
 */
export interface BusinessAccountTransferCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof BusinessAccountTransferCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {TransferRequestVerifiedBlockchainLocation}
     * @memberof BusinessAccountTransferCreationRequest
     */
    'destination': TransferRequestVerifiedBlockchainLocation;
    /**
     * 
     * @type {Money}
     * @memberof BusinessAccountTransferCreationRequest
     */
    'amount': Money;
}
/**
 * 
 * @export
 * @interface CancelCreationRequest
 */
export interface CancelCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof CancelCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {ReversalReason}
     * @memberof CancelCreationRequest
     */
    'reason'?: ReversalReason;
}
/**
 * 
 * @export
 * @interface CancelPaymentResponse
 */
export interface CancelPaymentResponse {
    /**
     * 
     * @type {DetailedCancel}
     * @memberof CancelPaymentResponse
     */
    'data'?: DetailedCancel;
}
/**
 * Enumerated status of the payment. `pending` means the payment is waiting to be processed. `confirmed` means the payment has been approved by the bank and the merchant can treat it as successful, but settlement funds are not yet available to the merchant.  `paid` means settlement funds have been received and are available to the merchant. `failed` means something went wrong (most commonly that the payment was denied). Terminal states are `paid` and `failed`.
 * @export
 * @enum {string}
 */

export const CancelRefundReversalStatus = {
    Pending: 'pending',
    Confirmed: 'confirmed',
    Paid: 'paid',
    Failed: 'failed'
} as const;

export type CancelRefundReversalStatus = typeof CancelRefundReversalStatus[keyof typeof CancelRefundReversalStatus];


/**
 * 
 * @export
 * @interface CaptureCreationRequest
 */
export interface CaptureCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof CaptureCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof CaptureCreationRequest
     */
    'amount'?: FiatMoneyUsd;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Card
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof Card
     */
    'status': ExternalFiatAccountStatus;
    /**
     * 
     * @type {BillingDetails}
     * @memberof Card
     */
    'billingDetails': BillingDetails;
    /**
     * Two digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof Card
     */
    'expMonth': number;
    /**
     * Four digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof Card
     */
    'expYear': number;
    /**
     * The network of the card.
     * @type {string}
     * @memberof Card
     */
    'network': CardNetworkEnum;
    /**
     * The last 4 digits of the card.
     * @type {string}
     * @memberof Card
     */
    'last4': string;
    /**
     * The bank identification number (BIN), the first 6 digits of the card.
     * @type {string}
     * @memberof Card
     */
    'bin'?: string;
    /**
     * The country code of the issuer bank. Follows the ISO 3166-1 alpha-2 standard.
     * @type {string}
     * @memberof Card
     */
    'issuerCountry'?: string;
    /**
     * The funding type of the card. Possible values are `credit`, `debit`, `prepaid`, and `unknown`.
     * @type {string}
     * @memberof Card
     */
    'fundingType'?: CardFundingTypeEnum;
    /**
     * A UUID that uniquely identifies the account number. If the same account is used more than once, each card object will have a different id, but the fingerprint will stay the same.
     * @type {string}
     * @memberof Card
     */
    'fingerprint': string;
    /**
     * 
     * @type {VerificationErrorCode}
     * @memberof Card
     */
    'errorCode'?: VerificationErrorCode | null;
    /**
     * 
     * @type {CardVerificationResponse}
     * @memberof Card
     */
    'verification': CardVerificationResponse;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof Card
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof Card
     */
    'metadata': MetadataPhoneEmail;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Card
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Card
     */
    'updateDate': string;
}

export const CardNetworkEnum = {
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    Amex: 'AMEX',
    Unknown: 'UNKNOWN'
} as const;

export type CardNetworkEnum = typeof CardNetworkEnum[keyof typeof CardNetworkEnum];
export const CardFundingTypeEnum = {
    Credit: 'credit',
    Debit: 'debit',
    Prepaid: 'prepaid',
    Unknown: 'unknown'
} as const;

export type CardFundingTypeEnum = typeof CardFundingTypeEnum[keyof typeof CardFundingTypeEnum];

/**
 * 
 * @export
 * @interface CardCreationRequest
 */
export interface CardCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof CardCreationRequest
     */
    'idempotencyKey': string;
    /**
     * Universally unique identifier (UUID v4) of the public key used in encryption. NOTE the sandbox environment uses the default value of `key1`. For this reason the example supplied is `key1` rather than a UUID.
     * @type {string}
     * @memberof CardCreationRequest
     */
    'keyId'?: string;
    /**
     * PGP encrypted base64 encoded string. Contains Number and CVV. * **Number**: Card number. No spaces or other separators. REQUIRED * **CVV (Card Verification Number)**: Three or four digit security code. REQUIRED\' 
     * @type {string}
     * @memberof CardCreationRequest
     */
    'encryptedData': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof CardCreationRequest
     */
    'billingDetails': BillingDetails;
    /**
     * Two digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof CardCreationRequest
     */
    'expMonth': number;
    /**
     * Four digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof CardCreationRequest
     */
    'expYear': number;
    /**
     * 
     * @type {MetadataCardAndAch}
     * @memberof CardCreationRequest
     */
    'metadata': MetadataCardAndAch;
}
/**
 * 
 * @export
 * @interface CardUpdate
 */
export interface CardUpdate {
    /**
     * Universally unique identifier (UUID v4) of the public key used in encryption. NOTE the sandbox environment uses the default value of `key1`. For this reason the example supplied is `key1` rather than a UUID.
     * @type {string}
     * @memberof CardUpdate
     */
    'keyId': string;
    /**
     * PGP encrypted base64 encoded string. Contains CVV. * **CVV (Card Verification Number)**: Three or four digit security code. REQUIRED\' 
     * @type {string}
     * @memberof CardUpdate
     */
    'encryptedData': string;
    /**
     * Two digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof CardUpdate
     */
    'expMonth': number;
    /**
     * Four digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof CardUpdate
     */
    'expYear': number;
}
/**
 * Indicates the status of the card for verification purposes.
 * @export
 * @interface CardVerificationResponse
 */
export interface CardVerificationResponse {
    /**
     * Status of the AVS check. Raw AVS response, expressed as an upper-case letter. `not_requested` indicates check was not made. `pending` is pending/processing.
     * @type {string}
     * @memberof CardVerificationResponse
     */
    'avs': string;
    /**
     * 
     * @type {CvvResults}
     * @memberof CardVerificationResponse
     */
    'cvv': CvvResults;
}
/**
 * A blockchain that a given currency is available on.
 * @export
 * @enum {string}
 */

export const Chain = {
    Algo: 'ALGO',
    Avax: 'AVAX',
    Btc: 'BTC',
    Eth: 'ETH',
    Flow: 'FLOW',
    Hbar: 'HBAR',
    Matic: 'MATIC',
    Sol: 'SOL',
    Trx: 'TRX',
    Xlm: 'XLM'
} as const;

export type Chain = typeof Chain[keyof typeof Chain];


/**
 * 
 * @export
 * @interface ChannelResponse
 */
export interface ChannelResponse {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof ChannelResponse
     */
    'id'?: string;
    /**
     * Flag to indicate whether the channel is configured as default. At most one of the channels will have this flag set to true and the default channel is used when a payment request does not have the `channel` property set.
     * @type {boolean}
     * @memberof ChannelResponse
     */
    'default'?: boolean;
    /**
     * Descriptor that appears on cardholders\' bank statements for card payments submitted through this channel.
     * @type {string}
     * @memberof ChannelResponse
     */
    'cardDescriptor'?: string;
    /**
     * Descriptor that appears on end-users\' bank statements for ACH payments submitted through this channel.
     * @type {string}
     * @memberof ChannelResponse
     */
    'achDescriptor'?: string;
}
/**
 * Enumerated category of the chargeback status codes based on the chargeback status code.
 * @export
 * @enum {string}
 */

export const ChargebackCategories = {
    CanceledRecurringPayment: 'Canceled Recurring Payment',
    CustomerDispute: 'Customer Dispute',
    Fraudulent: 'Fraudulent',
    General: 'General',
    ProcessingError: 'Processing Error',
    NotDefined: 'Not Defined'
} as const;

export type ChargebackCategories = typeof ChargebackCategories[keyof typeof ChargebackCategories];


/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * 
     * @type {number}
     * @memberof Conflict
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Conflict
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateACHBankAccountResponse
 */
export interface CreateACHBankAccountResponse {
    /**
     * 
     * @type {ACH}
     * @memberof CreateACHBankAccountResponse
     */
    'data'?: ACH;
}
/**
 * 
 * @export
 * @interface CreateAchAccountResponse
 */
export interface CreateAchAccountResponse {
    /**
     * 
     * @type {MockAchAccountResponse}
     * @memberof CreateAchAccountResponse
     */
    'data'?: MockAchAccountResponse;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountPayoutResponse
 */
export interface CreateBusinessAccountPayoutResponse {
    /**
     * 
     * @type {PayoutBusinessAccount}
     * @memberof CreateBusinessAccountPayoutResponse
     */
    'data'?: PayoutBusinessAccount;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountRecipientAddressResponse
 */
export interface CreateBusinessAccountRecipientAddressResponse {
    /**
     * 
     * @type {BusinessAccountRecipientAddressObject}
     * @memberof CreateBusinessAccountRecipientAddressResponse
     */
    'data'?: BusinessAccountRecipientAddressObject;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountSenBankAccountResponse
 */
export interface CreateBusinessAccountSenBankAccountResponse {
    /**
     * 
     * @type {SenFiatAccountResponse}
     * @memberof CreateBusinessAccountSenBankAccountResponse
     */
    'data'?: SenFiatAccountResponse;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountSignetBankAccountResponse
 */
export interface CreateBusinessAccountSignetBankAccountResponse {
    /**
     * 
     * @type {SignetFiatAccountResponse}
     * @memberof CreateBusinessAccountSignetBankAccountResponse
     */
    'data'?: SignetFiatAccountResponse;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountTransferResponse
 */
export interface CreateBusinessAccountTransferResponse {
    /**
     * 
     * @type {Transfer}
     * @memberof CreateBusinessAccountTransferResponse
     */
    'data'?: Transfer;
}
/**
 * 
 * @export
 * @interface CreateBusinessAccountWireBankAccountResponse
 */
export interface CreateBusinessAccountWireBankAccountResponse {
    /**
     * 
     * @type {Wire}
     * @memberof CreateBusinessAccountWireBankAccountResponse
     */
    'data'?: Wire;
}
/**
 * 
 * @export
 * @interface CreateCardResponse
 */
export interface CreateCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof CreateCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface CreateMockChargebackResponse
 */
export interface CreateMockChargebackResponse {
    /**
     * 
     * @type {object}
     * @memberof CreateMockChargebackResponse
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface CreatePaymentResponse
 */
export interface CreatePaymentResponse {
    /**
     * 
     * @type {DetailedPayment}
     * @memberof CreatePaymentResponse
     */
    'data'?: DetailedPayment;
}
/**
 * 
 * @export
 * @interface CreatePayoutResponse
 */
export interface CreatePayoutResponse {
    /**
     * 
     * @type {Payout}
     * @memberof CreatePayoutResponse
     */
    'data'?: Payout;
}
/**
 * 
 * @export
 * @interface CreateSEPABankAccountResponse
 */
export interface CreateSEPABankAccountResponse {
    /**
     * 
     * @type {SEPA}
     * @memberof CreateSEPABankAccountResponse
     */
    'data'?: SEPA;
}
/**
 * 
 * @export
 * @interface CreateSenPaymentResponse
 */
export interface CreateSenPaymentResponse {
    /**
     * 
     * @type {MockSenPaymentResponse}
     * @memberof CreateSenPaymentResponse
     */
    'data'?: MockSenPaymentResponse;
}
/**
 * 
 * @export
 * @interface CreateSepaPaymentResponse
 */
export interface CreateSepaPaymentResponse {
    /**
     * 
     * @type {MockSepaPaymentResponse}
     * @memberof CreateSepaPaymentResponse
     */
    'data'?: MockSepaPaymentResponse;
}
/**
 * 
 * @export
 * @interface CreateTransferResponse
 */
export interface CreateTransferResponse {
    /**
     * 
     * @type {Transfer}
     * @memberof CreateTransferResponse
     */
    'data'?: Transfer;
}
/**
 * 
 * @export
 * @interface CreateWalletResponse
 */
export interface CreateWalletResponse {
    /**
     * 
     * @type {Wallet}
     * @memberof CreateWalletResponse
     */
    'data'?: Wallet;
}
/**
 * 
 * @export
 * @interface CreateWireBankAccountResponse
 */
export interface CreateWireBankAccountResponse {
    /**
     * 
     * @type {Wire}
     * @memberof CreateWireBankAccountResponse
     */
    'data'?: Wire;
}
/**
 * 
 * @export
 * @interface CreateWirePaymentResponse
 */
export interface CreateWirePaymentResponse {
    /**
     * 
     * @type {MockWirePaymentResponse}
     * @memberof CreateWirePaymentResponse
     */
    'data'?: MockWirePaymentResponse;
}
/**
 * A currency associated with a balance or address.
 * @export
 * @enum {string}
 */

export const Currency = {
    Usd: 'USD',
    Eur: 'EUR',
    Btc: 'BTC',
    Eth: 'ETH'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * Enumerated status of the check. `not_requested` indicates check was not made. `pass` indicates value is correct. `fail` indicates value is incorrect. `unavailable` indicates card issuer did not do the provided check. `pending` indicates check is pending/processing.
 * @export
 * @enum {string}
 */

export const CvvResults = {
    NotRequested: 'not_requested',
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Pending: 'pending'
} as const;

export type CvvResults = typeof CvvResults[keyof typeof CvvResults];


/**
 * 
 * @export
 * @interface DeleteUnsubscribeResponse
 */
export interface DeleteUnsubscribeResponse {
    /**
     * Unsubscribe response object. No fields as of now.
     * @type {object}
     * @memberof DeleteUnsubscribeResponse
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface DetailedCancel
 */
export interface DetailedCancel {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof DetailedCancel
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof DetailedCancel
     */
    'type': DetailedCancelTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof DetailedCancel
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof DetailedCancel
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedCancel
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof DetailedCancel
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof DetailedCancel
     */
    'description'?: DetailedCancelDescriptionEnum;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof DetailedCancel
     */
    'status': CancelRefundReversalStatus;
    /**
     * 
     * @type {BasicPayment}
     * @memberof DetailedCancel
     */
    'originalPayment'?: BasicPayment;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedCancel
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Payment tracking reference. Will be present once known.
     * @type {string}
     * @memberof DetailedCancel
     */
    'trackingRef'?: string | null;
    /**
     * 
     * @type {PaymentErrorCode}
     * @memberof DetailedCancel
     */
    'errorCode'?: PaymentErrorCode | null;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof DetailedCancel
     */
    'metadata'?: MetadataPhoneEmail;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof DetailedCancel
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * If the cancel was made after a cutoff time period, it will be processed as a refund. This flag indicates that the cancel was processed as a refund\'
     * @type {boolean}
     * @memberof DetailedCancel
     */
    'refund'?: boolean;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedCancel
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedCancel
     */
    'updateDate'?: string;
}

export const DetailedCancelTypeEnum = {
    Cancel: 'cancel'
} as const;

export type DetailedCancelTypeEnum = typeof DetailedCancelTypeEnum[keyof typeof DetailedCancelTypeEnum];
export const DetailedCancelDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type DetailedCancelDescriptionEnum = typeof DetailedCancelDescriptionEnum[keyof typeof DetailedCancelDescriptionEnum];

/**
 * 
 * @export
 * @interface DetailedPayment
 */
export interface DetailedPayment {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof DetailedPayment
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof DetailedPayment
     */
    'type': DetailedPaymentTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof DetailedPayment
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof DetailedPayment
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPayment
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof DetailedPayment
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof DetailedPayment
     */
    'description'?: DetailedPaymentDescriptionEnum;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof DetailedPayment
     */
    'status': PaymentStatus;
    /**
     * Determines if a payment has successfully been captured. This property is only present for payments that did not use auto capture.
     * @type {boolean}
     * @memberof DetailedPayment
     */
    'captured'?: boolean;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPayment
     */
    'captureAmount'?: FiatMoneyUsd;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPayment
     */
    'captureDate'?: string;
    /**
     * 
     * @type {RequiredAction}
     * @memberof DetailedPayment
     */
    'requiredAction'?: RequiredAction;
    /**
     * 
     * @type {PaymentVerificationResponse}
     * @memberof DetailedPayment
     */
    'verification'?: PaymentVerificationResponse;
    /**
     * 
     * @type {BasicCancel}
     * @memberof DetailedPayment
     */
    'cancel'?: BasicCancel | null;
    /**
     * 
     * @type {Array<BasicRefund>}
     * @memberof DetailedPayment
     */
    'refunds'?: Array<BasicRefund>;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPayment
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Payment tracking reference. Will be present once known.
     * @type {string}
     * @memberof DetailedPayment
     */
    'trackingRef'?: string | null;
    /**
     * 
     * @type {PaymentErrorCode}
     * @memberof DetailedPayment
     */
    'errorCode'?: PaymentErrorCode | null;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof DetailedPayment
     */
    'metadata'?: MetadataPhoneEmail;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof DetailedPayment
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof DetailedPayment
     */
    'channel'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPayment
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPayment
     */
    'updateDate'?: string;
}

export const DetailedPaymentTypeEnum = {
    Payment: 'payment'
} as const;

export type DetailedPaymentTypeEnum = typeof DetailedPaymentTypeEnum[keyof typeof DetailedPaymentTypeEnum];
export const DetailedPaymentDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type DetailedPaymentDescriptionEnum = typeof DetailedPaymentDescriptionEnum[keyof typeof DetailedPaymentDescriptionEnum];

/**
 * 
 * @export
 * @interface DetailedPaymentPolymorphic
 */
export interface DetailedPaymentPolymorphic {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'type': DetailedPaymentPolymorphicTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPaymentPolymorphic
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof DetailedPaymentPolymorphic
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'description'?: DetailedPaymentPolymorphicDescriptionEnum;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof DetailedPaymentPolymorphic
     */
    'status': PaymentStatus;
    /**
     * 
     * @type {RequiredAction}
     * @memberof DetailedPaymentPolymorphic
     */
    'requiredAction'?: RequiredAction;
    /**
     * 
     * @type {PaymentVerificationResponse}
     * @memberof DetailedPaymentPolymorphic
     */
    'verification'?: PaymentVerificationResponse;
    /**
     * 
     * @type {BasicPayment}
     * @memberof DetailedPaymentPolymorphic
     */
    'originalPayment'?: BasicPayment;
    /**
     * 
     * @type {BasicCancel}
     * @memberof DetailedPaymentPolymorphic
     */
    'cancel'?: BasicCancel | null;
    /**
     * 
     * @type {Array<BasicRefund>}
     * @memberof DetailedPaymentPolymorphic
     */
    'refunds'?: Array<BasicRefund> | null;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPaymentPolymorphic
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Payment tracking reference. Will be present once known.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'trackingRef'?: string | null;
    /**
     * External network identifier which will be present once provided from the applicable network.   Examples: * **Input/Output Message Accountability Data (IMAD/OMAD)**: unique number given to each FedWire payment when using the Federal Reserve Bank Service which can be used to investigate and track wire transfers. 
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'externalRef'?: string;
    /**
     * 
     * @type {PaymentErrorCode}
     * @memberof DetailedPaymentPolymorphic
     */
    'errorCode'?: PaymentErrorCode | null;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof DetailedPaymentPolymorphic
     */
    'metadata'?: MetadataPhoneEmail;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'channel'?: string;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof DetailedPaymentPolymorphic
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPaymentPolymorphic
     */
    'updateDate'?: string;
}

export const DetailedPaymentPolymorphicTypeEnum = {
    Payment: 'payment',
    Refund: 'refund',
    Cancel: 'cancel'
} as const;

export type DetailedPaymentPolymorphicTypeEnum = typeof DetailedPaymentPolymorphicTypeEnum[keyof typeof DetailedPaymentPolymorphicTypeEnum];
export const DetailedPaymentPolymorphicDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type DetailedPaymentPolymorphicDescriptionEnum = typeof DetailedPaymentPolymorphicDescriptionEnum[keyof typeof DetailedPaymentPolymorphicDescriptionEnum];

/**
 * 
 * @export
 * @interface DetailedPayout
 */
export interface DetailedPayout {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof DetailedPayout
     */
    'id'?: string;
    /**
     * The identifier of the source wallet used to fund a payout.
     * @type {string}
     * @memberof DetailedPayout
     */
    'sourceWalletId'?: string;
    /**
     * 
     * @type {BankDestination}
     * @memberof DetailedPayout
     */
    'destination'?: BankDestination;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPayout
     */
    'amount'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedPayout
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Status of the payout. Status `pending` indicates that the payout is in process; `complete` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof DetailedPayout
     */
    'status'?: DetailedPayoutStatusEnum;
    /**
     * A payout tracking reference. Will be present once known.
     * @type {any}
     * @memberof DetailedPayout
     */
    'trackingRef'?: any | null;
    /**
     * External network identifier which will be present once provided from the applicable network.   Examples: * **Input/Output Message Accountability Data (IMAD/OMAD)**: unique number given to each FedWire payment when using the Federal Reserve Bank Service which can be used to investigate and track wire transfers. 
     * @type {string}
     * @memberof DetailedPayout
     */
    'externalRef'?: string;
    /**
     * 
     * @type {PayoutErrorCode}
     * @memberof DetailedPayout
     */
    'errorCode'?: PayoutErrorCode | null;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof DetailedPayout
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * 
     * @type {PayoutBusinessAccountAdjustments}
     * @memberof DetailedPayout
     */
    'adjustments'?: PayoutBusinessAccountAdjustments | null;
    /**
     * 
     * @type {UnwithdrawalObject}
     * @memberof DetailedPayout
     */
    'return'?: UnwithdrawalObject | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPayout
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedPayout
     */
    'updateDate'?: string;
}

export const DetailedPayoutStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type DetailedPayoutStatusEnum = typeof DetailedPayoutStatusEnum[keyof typeof DetailedPayoutStatusEnum];

/**
 * 
 * @export
 * @interface DetailedRefund
 */
export interface DetailedRefund {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof DetailedRefund
     */
    'id': string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof DetailedRefund
     */
    'type': DetailedRefundTypeEnum;
    /**
     * Unique system generated identifier for the merchant.
     * @type {string}
     * @memberof DetailedRefund
     */
    'merchantId': string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof DetailedRefund
     */
    'merchantWalletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedRefund
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {SourceResponse}
     * @memberof DetailedRefund
     */
    'source': SourceResponse;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof DetailedRefund
     */
    'description'?: DetailedRefundDescriptionEnum;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof DetailedRefund
     */
    'status': CancelRefundReversalStatus;
    /**
     * 
     * @type {BasicPayment}
     * @memberof DetailedRefund
     */
    'originalPayment'?: BasicPayment;
    /**
     * 
     * @type {BasicCancel}
     * @memberof DetailedRefund
     */
    'cancel'?: BasicCancel | null;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof DetailedRefund
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Payment tracking reference. Will be present once known.
     * @type {string}
     * @memberof DetailedRefund
     */
    'trackingRef'?: string | null;
    /**
     * 
     * @type {PaymentErrorCode}
     * @memberof DetailedRefund
     */
    'errorCode'?: PaymentErrorCode | null;
    /**
     * 
     * @type {MetadataPhoneEmail}
     * @memberof DetailedRefund
     */
    'metadata'?: MetadataPhoneEmail;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof DetailedRefund
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedRefund
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof DetailedRefund
     */
    'updateDate'?: string;
}

export const DetailedRefundTypeEnum = {
    Refund: 'refund'
} as const;

export type DetailedRefundTypeEnum = typeof DetailedRefundTypeEnum[keyof typeof DetailedRefundTypeEnum];
export const DetailedRefundDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type DetailedRefundDescriptionEnum = typeof DetailedRefundDescriptionEnum[keyof typeof DetailedRefundDescriptionEnum];

/**
 * ECI (electronic commerce indicator) value returned by Directory Servers (namely Visa, MasterCard, JCB, and American Express) indicating the outcome of authentication attempted on transactions enforced by 3DS.
 * @export
 * @enum {string}
 */

export const Eci = {
    _00: '00',
    _01: '01',
    _02: '02',
    _05: '05',
    _06: '06',
    _07: '07'
} as const;

export type Eci = typeof Eci[keyof typeof Eci];


/**
 * Status of the account. A `pending` status indicates that the linking is in-progress; `complete` indicates the account was linked successfully; `failed` indicates it failed.
 * @export
 * @enum {string}
 */

export const ExternalFiatAccountStatus = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type ExternalFiatAccountStatus = typeof ExternalFiatAccountStatus[keyof typeof ExternalFiatAccountStatus];


/**
 * 
 * @export
 * @interface FiatMoney
 */
export interface FiatMoney {
    /**
     * Magnitude of the amount, in units of the currency, with a `.`.
     * @type {string}
     * @memberof FiatMoney
     */
    'amount': string;
    /**
     * Currency code.
     * @type {string}
     * @memberof FiatMoney
     */
    'currency': FiatMoneyCurrencyEnum;
}

export const FiatMoneyCurrencyEnum = {
    Usd: 'USD',
    Eur: 'EUR'
} as const;

export type FiatMoneyCurrencyEnum = typeof FiatMoneyCurrencyEnum[keyof typeof FiatMoneyCurrencyEnum];

/**
 * 
 * @export
 * @interface FiatMoneyUsd
 */
export interface FiatMoneyUsd {
    /**
     * Magnitude of the amount, in units of the currency, with a `.`.
     * @type {string}
     * @memberof FiatMoneyUsd
     */
    'amount': string;
    /**
     * Currency code.
     * @type {string}
     * @memberof FiatMoneyUsd
     */
    'currency': FiatMoneyUsdCurrencyEnum;
}

export const FiatMoneyUsdCurrencyEnum = {
    Usd: 'USD'
} as const;

export type FiatMoneyUsdCurrencyEnum = typeof FiatMoneyUsdCurrencyEnum[keyof typeof FiatMoneyUsdCurrencyEnum];

/**
 * 
 * @export
 * @interface GenerateAddressRequest
 */
export interface GenerateAddressRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof GenerateAddressRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Currency}
     * @memberof GenerateAddressRequest
     */
    'currency': Currency | null;
    /**
     * 
     * @type {Chain}
     * @memberof GenerateAddressRequest
     */
    'chain': Chain;
}
/**
 * 
 * @export
 * @interface GenerateAddressResponse
 */
export interface GenerateAddressResponse {
    /**
     * 
     * @type {AddressObject}
     * @memberof GenerateAddressResponse
     */
    'data'?: AddressObject;
}
/**
 * 
 * @export
 * @interface GenerateBusinessAccountDepositAddressResponse
 */
export interface GenerateBusinessAccountDepositAddressResponse {
    /**
     * 
     * @type {AddressObject}
     * @memberof GenerateBusinessAccountDepositAddressResponse
     */
    'data'?: AddressObject;
}
/**
 * 
 * @export
 * @interface GetACHBankAccountResponse
 */
export interface GetACHBankAccountResponse {
    /**
     * 
     * @type {ACH}
     * @memberof GetACHBankAccountResponse
     */
    'data'?: ACH;
}
/**
 * 
 * @export
 * @interface GetAddressesResponse
 */
export interface GetAddressesResponse {
    /**
     * 
     * @type {Array<AddressObject>}
     * @memberof GetAddressesResponse
     */
    'data'?: Array<AddressObject>;
}
/**
 * 
 * @export
 * @interface GetBalancesResponse
 */
export interface GetBalancesResponse {
    /**
     * 
     * @type {Balances}
     * @memberof GetBalancesResponse
     */
    'data'?: Balances;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountBalancesResponse
 */
export interface GetBusinessAccountBalancesResponse {
    /**
     * 
     * @type {Balances}
     * @memberof GetBusinessAccountBalancesResponse
     */
    'data'?: Balances;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountDepositAddressesResponse
 */
export interface GetBusinessAccountDepositAddressesResponse {
    /**
     * 
     * @type {Array<AddressObject>}
     * @memberof GetBusinessAccountDepositAddressesResponse
     */
    'data'?: Array<AddressObject>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountPayoutResponse
 */
export interface GetBusinessAccountPayoutResponse {
    /**
     * 
     * @type {PayoutBusinessAccount}
     * @memberof GetBusinessAccountPayoutResponse
     */
    'data'?: PayoutBusinessAccount;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountPayoutsResponse
 */
export interface GetBusinessAccountPayoutsResponse {
    /**
     * 
     * @type {Array<PayoutBusinessAccount>}
     * @memberof GetBusinessAccountPayoutsResponse
     */
    'data'?: Array<PayoutBusinessAccount>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountRecipientAddressesResponse
 */
export interface GetBusinessAccountRecipientAddressesResponse {
    /**
     * 
     * @type {Array<BusinessAccountRecipientAddressObject>}
     * @memberof GetBusinessAccountRecipientAddressesResponse
     */
    'data'?: Array<BusinessAccountRecipientAddressObject>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSenBankAccountResponse
 */
export interface GetBusinessAccountSenBankAccountResponse {
    /**
     * 
     * @type {SenFiatAccountResponse}
     * @memberof GetBusinessAccountSenBankAccountResponse
     */
    'data'?: SenFiatAccountResponse;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSenBankAccounts200Response
 */
export interface GetBusinessAccountSenBankAccounts200Response {
    /**
     * 
     * @type {Array<SenFiatAccountResponse>}
     * @memberof GetBusinessAccountSenBankAccounts200Response
     */
    'data'?: Array<SenFiatAccountResponse>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSenInstructionsBankAccountResponse
 */
export interface GetBusinessAccountSenInstructionsBankAccountResponse {
    /**
     * 
     * @type {SenInstruction}
     * @memberof GetBusinessAccountSenInstructionsBankAccountResponse
     */
    'data'?: SenInstruction;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSignetBankAccountResponse
 */
export interface GetBusinessAccountSignetBankAccountResponse {
    /**
     * 
     * @type {SignetFiatAccountResponse}
     * @memberof GetBusinessAccountSignetBankAccountResponse
     */
    'data'?: SignetFiatAccountResponse;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSignetBankAccountsResponse
 */
export interface GetBusinessAccountSignetBankAccountsResponse {
    /**
     * 
     * @type {Array<SignetFiatAccountResponse>}
     * @memberof GetBusinessAccountSignetBankAccountsResponse
     */
    'data'?: Array<SignetFiatAccountResponse>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountSignetInstructionsBankAccountResponse
 */
export interface GetBusinessAccountSignetInstructionsBankAccountResponse {
    /**
     * 
     * @type {SignetInstruction}
     * @memberof GetBusinessAccountSignetInstructionsBankAccountResponse
     */
    'data'?: SignetInstruction;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountTransferResponse
 */
export interface GetBusinessAccountTransferResponse {
    /**
     * 
     * @type {Transfer}
     * @memberof GetBusinessAccountTransferResponse
     */
    'data'?: Transfer;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountWireBankAccountResponse
 */
export interface GetBusinessAccountWireBankAccountResponse {
    /**
     * 
     * @type {Wire}
     * @memberof GetBusinessAccountWireBankAccountResponse
     */
    'data'?: Wire;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountWireBankAccounts200Response
 */
export interface GetBusinessAccountWireBankAccounts200Response {
    /**
     * 
     * @type {Array<Wire>}
     * @memberof GetBusinessAccountWireBankAccounts200Response
     */
    'data'?: Array<Wire>;
}
/**
 * 
 * @export
 * @interface GetBusinessAccountWireInstructionsBankAccountResponse
 */
export interface GetBusinessAccountWireInstructionsBankAccountResponse {
    /**
     * 
     * @type {WireInstruction}
     * @memberof GetBusinessAccountWireInstructionsBankAccountResponse
     */
    'data'?: WireInstruction;
}
/**
 * 
 * @export
 * @interface GetCardResponse
 */
export interface GetCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof GetCardResponse
     */
    'data'?: Card;
}
/**
 * 
 * @export
 * @interface GetCardsResponse
 */
export interface GetCardsResponse {
    /**
     * 
     * @type {Array<SimpleCard>}
     * @memberof GetCardsResponse
     */
    'data'?: Array<SimpleCard>;
}
/**
 * 
 * @export
 * @interface GetChargebackResponse
 */
export interface GetChargebackResponse {
    /**
     * 
     * @type {BasicChargeback}
     * @memberof GetChargebackResponse
     */
    'data'?: BasicChargeback;
}
/**
 * 
 * @export
 * @interface GetChargebacksResponse
 */
export interface GetChargebacksResponse {
    /**
     * 
     * @type {Array<BasicChargeback>}
     * @memberof GetChargebacksResponse
     */
    'data'?: Array<BasicChargeback>;
}
/**
 * 
 * @export
 * @interface GetConfigResponse
 */
export interface GetConfigResponse {
    /**
     * 
     * @type {AccountConfiguration}
     * @memberof GetConfigResponse
     */
    'data'?: AccountConfiguration;
}
/**
 * 
 * @export
 * @interface GetListSubscriptionsResponse
 */
export interface GetListSubscriptionsResponse {
    /**
     * 
     * @type {Array<SubscriptionResponse>}
     * @memberof GetListSubscriptionsResponse
     */
    'data'?: Array<SubscriptionResponse>;
}
/**
 * 
 * @export
 * @interface GetPaymentResponse
 */
export interface GetPaymentResponse {
    /**
     * 
     * @type {DetailedPaymentPolymorphic}
     * @memberof GetPaymentResponse
     */
    'data'?: DetailedPaymentPolymorphic;
}
/**
 * 
 * @export
 * @interface GetPaymentsResponse
 */
export interface GetPaymentsResponse {
    /**
     * 
     * @type {Array<BasicPayment>}
     * @memberof GetPaymentsResponse
     */
    'data'?: Array<BasicPayment>;
}
/**
 * 
 * @export
 * @interface GetPayoutResponse
 */
export interface GetPayoutResponse {
    /**
     * 
     * @type {DetailedPayout}
     * @memberof GetPayoutResponse
     */
    'data'?: DetailedPayout;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponse
 */
export interface GetPayoutsResponse {
    /**
     * 
     * @type {Array<Payout>}
     * @memberof GetPayoutsResponse
     */
    'data'?: Array<Payout>;
}
/**
 * 
 * @export
 * @interface GetPublicKeyResponse
 */
export interface GetPublicKeyResponse {
    /**
     * 
     * @type {PublicKey}
     * @memberof GetPublicKeyResponse
     */
    'data'?: PublicKey;
}
/**
 * 
 * @export
 * @interface GetReturnsResponse
 */
export interface GetReturnsResponse {
    /**
     * 
     * @type {Array<UnwithdrawalObject>}
     * @memberof GetReturnsResponse
     */
    'data'?: Array<UnwithdrawalObject>;
}
/**
 * 
 * @export
 * @interface GetReversalsResponse
 */
export interface GetReversalsResponse {
    /**
     * 
     * @type {Array<Reversal>}
     * @memberof GetReversalsResponse
     */
    'data'?: Array<Reversal>;
}
/**
 * 
 * @export
 * @interface GetSEPABankAccountResponse
 */
export interface GetSEPABankAccountResponse {
    /**
     * 
     * @type {SEPA}
     * @memberof GetSEPABankAccountResponse
     */
    'data'?: SEPA;
}
/**
 * 
 * @export
 * @interface GetSEPAInstructionsBankAccountResponse
 */
export interface GetSEPAInstructionsBankAccountResponse {
    /**
     * 
     * @type {SEPAInstruction}
     * @memberof GetSEPAInstructionsBankAccountResponse
     */
    'data'?: SEPAInstruction;
}
/**
 * 
 * @export
 * @interface GetSettlementResponse
 */
export interface GetSettlementResponse {
    /**
     * 
     * @type {Settlement}
     * @memberof GetSettlementResponse
     */
    'data'?: Settlement;
}
/**
 * 
 * @export
 * @interface GetSettlementsResponse
 */
export interface GetSettlementsResponse {
    /**
     * 
     * @type {Array<Settlement>}
     * @memberof GetSettlementsResponse
     */
    'data'?: Array<Settlement>;
}
/**
 * 
 * @export
 * @interface GetStablecoinsResponse
 */
export interface GetStablecoinsResponse {
    /**
     * A list of stablecoin objects containing its name, symbol, total amount, and per-chain amount.
     * @type {Array<Stablecoin>}
     * @memberof GetStablecoinsResponse
     */
    'data'?: Array<Stablecoin>;
}
/**
 * 
 * @export
 * @interface GetTransferResponse
 */
export interface GetTransferResponse {
    /**
     * 
     * @type {TransferDetailedTransfer}
     * @memberof GetTransferResponse
     */
    'data'?: TransferDetailedTransfer;
}
/**
 * 
 * @export
 * @interface GetWalletResponse
 */
export interface GetWalletResponse {
    /**
     * 
     * @type {Wallet}
     * @memberof GetWalletResponse
     */
    'data'?: Wallet;
}
/**
 * 
 * @export
 * @interface GetWalletsResponse
 */
export interface GetWalletsResponse {
    /**
     * 
     * @type {Array<Wallet>}
     * @memberof GetWalletsResponse
     */
    'data'?: Array<Wallet>;
}
/**
 * 
 * @export
 * @interface GetWireBankAccountResponse
 */
export interface GetWireBankAccountResponse {
    /**
     * 
     * @type {Wire}
     * @memberof GetWireBankAccountResponse
     */
    'data'?: Wire;
}
/**
 * 
 * @export
 * @interface GetWireInstructionsBankAccountResponse
 */
export interface GetWireInstructionsBankAccountResponse {
    /**
     * 
     * @type {WireInstruction}
     * @memberof GetWireInstructionsBankAccountResponse
     */
    'data'?: WireInstruction;
}
/**
 * The identity of the originator. Identities are required when:   * `destination.type: \"blockchain\"`   * `destination.chain: \"ETH\"`   * `amount.amount` >= $3,000 in value 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * The type of identity for the originator. * `individual` - A uniquely distinguishable individual. * `business` - Any entity other than a natural person that can establish a permanent customer relationship with an affected entity or otherwise own property. This can include companies, foundations, anstalt, partnerships, associations and other relevantly similar entities. 
     * @type {string}
     * @memberof Identity
     */
    'type': IdentityTypeEnum;
    /**
     * Full name of the identity.
     * @type {string}
     * @memberof Identity
     */
    'name': string;
    /**
     * 
     * @type {Array<IdentityAddress>}
     * @memberof Identity
     */
    'addresses': Array<IdentityAddress>;
}

export const IdentityTypeEnum = {
    Individual: 'individual',
    Business: 'business'
} as const;

export type IdentityTypeEnum = typeof IdentityTypeEnum[keyof typeof IdentityTypeEnum];

/**
 * 
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
    /**
     * Line one of the street address.
     * @type {string}
     * @memberof IdentityAddress
     */
    'line1': string;
    /**
     * Line two of the street address.
     * @type {string}
     * @memberof IdentityAddress
     */
    'line2'?: string;
    /**
     * City portion of the address.
     * @type {string}
     * @memberof IdentityAddress
     */
    'city': string;
    /**
     * State / County / Province / Region portion of the address. If the country is US or Canada, then district is required and should use the two-letter code for the subdivision.
     * @type {string}
     * @memberof IdentityAddress
     */
    'district': string;
    /**
     * Postal / ZIP code of the address.
     * @type {string}
     * @memberof IdentityAddress
     */
    'postalCode': string;
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof IdentityAddress
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface LimitExceeded
 */
export interface LimitExceeded {
    /**
     * 
     * @type {number}
     * @memberof LimitExceeded
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof LimitExceeded
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListChannelsResponse
 */
export interface ListChannelsResponse {
    /**
     * 
     * @type {Array<ChannelResponse>}
     * @memberof ListChannelsResponse
     */
    'data'?: Array<ChannelResponse>;
}
/**
 * 
 * @export
 * @interface MetadataCardAndAch
 */
export interface MetadataCardAndAch {
    /**
     * Email of the user.
     * @type {string}
     * @memberof MetadataCardAndAch
     */
    'email': string;
    /**
     * Phone number of the user in E.164 format. We recommend using a library such as [libphonenumber](https://github.com/google/libphonenumber) to parse and validate phone numbers.
     * @type {string}
     * @memberof MetadataCardAndAch
     */
    'phoneNumber'?: string;
    /**
     * Hash of the session identifier; typically of the end user. This helps us make risk decisions and prevent fraud. IMPORTANT: Please hash the session identifier to prevent sending us actual session identifiers. 
     * @type {string}
     * @memberof MetadataCardAndAch
     */
    'sessionId': string;
    /**
     * Single IPv4 or IPv6 address of user\'
     * @type {string}
     * @memberof MetadataCardAndAch
     */
    'ipAddress': string;
}
/**
 * 
 * @export
 * @interface MetadataPayment
 */
export interface MetadataPayment {
    /**
     * Email of the user.
     * @type {string}
     * @memberof MetadataPayment
     */
    'email': string;
    /**
     * Phone number of the user in E.164 format. We recommend using a library such as [libphonenumber](https://github.com/google/libphonenumber) to parse and validate phone numbers.
     * @type {string}
     * @memberof MetadataPayment
     */
    'phoneNumber'?: string;
    /**
     * Hash of the session identifier; typically of the end user. This helps us make risk decisions and prevent fraud. IMPORTANT: Please hash the session identifier to prevent sending us actual session identifiers. 
     * @type {string}
     * @memberof MetadataPayment
     */
    'sessionId': string;
    /**
     * Single IPv4 or IPv6 address of user\'
     * @type {string}
     * @memberof MetadataPayment
     */
    'ipAddress': string;
}
/**
 * Additional properties related to the payout beneficiary.
 * @export
 * @interface MetadataPayout
 */
export interface MetadataPayout {
    /**
     * Email of the user.
     * @type {string}
     * @memberof MetadataPayout
     */
    'beneficiaryEmail': string;
}
/**
 * 
 * @export
 * @interface MetadataPhoneEmail
 */
export interface MetadataPhoneEmail {
    /**
     * Email of the user.
     * @type {string}
     * @memberof MetadataPhoneEmail
     */
    'email': string;
    /**
     * Phone number of the user in E.164 format. We recommend using a library such as [libphonenumber](https://github.com/google/libphonenumber) to parse and validate phone numbers.
     * @type {string}
     * @memberof MetadataPhoneEmail
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface MockAchAccount
 */
export interface MockAchAccount {
    /**
     * The account number of the ACH account.
     * @type {string}
     * @memberof MockAchAccount
     */
    'accountNumber': string;
    /**
     * The routing number of the ACH account.  For sandbox testing, valid routing numbers include `011000028`, `011201762`, `011500120`, `021214862`, `121000248`, `121140399`, `211073473`, `221172610`, and `011000138`. 
     * @type {string}
     * @memberof MockAchAccount
     */
    'routingNumber': string;
    /**
     * A description for the ACH account.
     * @type {string}
     * @memberof MockAchAccount
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface MockAchAccountCreationRequest
 */
export interface MockAchAccountCreationRequest {
    /**
     * 
     * @type {MockAchAccount}
     * @memberof MockAchAccountCreationRequest
     */
    'account': MockAchAccount;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockAchAccountCreationRequest
     */
    'balance': FiatMoneyUsd;
}
/**
 * 
 * @export
 * @interface MockAchAccountResponse
 */
export interface MockAchAccountResponse {
    /**
     * The processor token needs to be provided when linking an ACH account against this mock.
     * @type {string}
     * @memberof MockAchAccountResponse
     */
    'processorToken'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockAchAccountResponse
     */
    'balance'?: FiatMoneyUsd;
    /**
     * 
     * @type {MockAchAccount}
     * @memberof MockAchAccountResponse
     */
    'account'?: MockAchAccount;
}
/**
 * 
 * @export
 * @interface MockChargebackCreationRequest
 */
export interface MockChargebackCreationRequest {
    /**
     * The id of the payment to be charged back.  Each payment can only be charged back once.
     * @type {string}
     * @memberof MockChargebackCreationRequest
     */
    'paymentId': string;
}
/**
 * 
 * @export
 * @interface MockSenPaymentBeneficiaryBankInstruction
 */
export interface MockSenPaymentBeneficiaryBankInstruction {
    /**
     * Circle corporate Silvergate SEN account number that needs to be set as destination.
     * @type {string}
     * @memberof MockSenPaymentBeneficiaryBankInstruction
     */
    'accountNumber': string;
}
/**
 * 
 * @export
 * @interface MockSenPaymentRequest
 */
export interface MockSenPaymentRequest {
    /**
     * Circle tracking reference that needs to be set in the memo filed. This field is retrievable through the response during SEN account creation or via the bank instruction endpoint.
     * @type {string}
     * @memberof MockSenPaymentRequest
     */
    'trackingRef': string;
    /**
     * 
     * @type {FiatMoney}
     * @memberof MockSenPaymentRequest
     */
    'amount': FiatMoney;
    /**
     * 
     * @type {MockSenPaymentBeneficiaryBankInstruction}
     * @memberof MockSenPaymentRequest
     */
    'beneficiaryBank': MockSenPaymentBeneficiaryBankInstruction;
}
/**
 * 
 * @export
 * @interface MockSenPaymentResponse
 */
export interface MockSenPaymentResponse {
    /**
     * Wire tracking reference that needs to be set in the wire reference to beneficiary field. This field is retrievable through the response during wire creation or via the bank instruction endpoint.
     * @type {string}
     * @memberof MockSenPaymentResponse
     */
    'trackingRef'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockSenPaymentResponse
     */
    'amount'?: FiatMoneyUsd;
    /**
     * 
     * @type {MockSenPaymentBeneficiaryBankInstruction}
     * @memberof MockSenPaymentResponse
     */
    'beneficiaryBank'?: MockSenPaymentBeneficiaryBankInstruction;
    /**
     * Enumerated status of the wire payment. Status `pending` indicates that the wire payment is in process; `processed` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof MockSenPaymentResponse
     */
    'status'?: MockSenPaymentResponseStatusEnum;
}

export const MockSenPaymentResponseStatusEnum = {
    Pending: 'pending',
    Processed: 'processed',
    Failed: 'failed'
} as const;

export type MockSenPaymentResponseStatusEnum = typeof MockSenPaymentResponseStatusEnum[keyof typeof MockSenPaymentResponseStatusEnum];

/**
 * 
 * @export
 * @interface MockSepaPaymentRequest
 */
export interface MockSepaPaymentRequest {
    /**
     * SEPA tracking reference that needs to be set in the payment details or description.
     * @type {string}
     * @memberof MockSepaPaymentRequest
     */
    'trackingRef': string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockSepaPaymentRequest
     */
    'amount': FiatMoneyUsd;
}
/**
 * 
 * @export
 * @interface MockSepaPaymentResponse
 */
export interface MockSepaPaymentResponse {
    /**
     * SEPA tracking reference that needs to be set in the payment details or description.
     * @type {string}
     * @memberof MockSepaPaymentResponse
     */
    'trackingRef'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockSepaPaymentResponse
     */
    'amount'?: FiatMoneyUsd;
    /**
     * Enumerated status of the SEPA payment. Status `pending` indicates that the SEPA payment is in process; `processed` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof MockSepaPaymentResponse
     */
    'status'?: MockSepaPaymentResponseStatusEnum;
}

export const MockSepaPaymentResponseStatusEnum = {
    Pending: 'pending',
    Processed: 'processed',
    Failed: 'failed'
} as const;

export type MockSepaPaymentResponseStatusEnum = typeof MockSepaPaymentResponseStatusEnum[keyof typeof MockSepaPaymentResponseStatusEnum];

/**
 * 
 * @export
 * @interface MockWirePaymentBeneficiaryBankInstruction
 */
export interface MockWirePaymentBeneficiaryBankInstruction {
    /**
     * Virtual account number or Circle corporate Silvergate Wire account number that needs to be set as destination.
     * @type {string}
     * @memberof MockWirePaymentBeneficiaryBankInstruction
     */
    'accountNumber': string;
}
/**
 * 
 * @export
 * @interface MockWirePaymentRequest
 */
export interface MockWirePaymentRequest {
    /**
     * Wire tracking reference that needs to be set in the wire reference to beneficiary field. This field is retrievable through the response during wire creation or via the bank instruction endpoint.
     * @type {string}
     * @memberof MockWirePaymentRequest
     */
    'trackingRef': string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockWirePaymentRequest
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {MockWirePaymentBeneficiaryBankInstruction}
     * @memberof MockWirePaymentRequest
     */
    'beneficiaryBank': MockWirePaymentBeneficiaryBankInstruction;
}
/**
 * 
 * @export
 * @interface MockWirePaymentResponse
 */
export interface MockWirePaymentResponse {
    /**
     * Wire tracking reference that needs to be set in the wire reference to beneficiary field. This field is retrievable through the response during wire creation or via the bank instruction endpoint.
     * @type {string}
     * @memberof MockWirePaymentResponse
     */
    'trackingRef'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof MockWirePaymentResponse
     */
    'amount'?: FiatMoneyUsd;
    /**
     * 
     * @type {MockWirePaymentBeneficiaryBankInstruction}
     * @memberof MockWirePaymentResponse
     */
    'beneficiaryBank'?: MockWirePaymentBeneficiaryBankInstruction;
    /**
     * Enumerated status of the wire payment. Status `pending` indicates that the wire payment is in process; `processed` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof MockWirePaymentResponse
     */
    'status'?: MockWirePaymentResponseStatusEnum;
}

export const MockWirePaymentResponseStatusEnum = {
    Pending: 'pending',
    Processed: 'processed',
    Failed: 'failed'
} as const;

export type MockWirePaymentResponseStatusEnum = typeof MockWirePaymentResponseStatusEnum[keyof typeof MockWirePaymentResponseStatusEnum];

/**
 * Enumerated status of the check. `pass` indicates successful 3DS authentication. `fail` indicates failed 3DS authentication.
 * @export
 * @enum {string}
 */

export const Model3dsResults = {
    Pass: 'pass',
    Fail: 'fail'
} as const;

export type Model3dsResults = typeof Model3dsResults[keyof typeof Model3dsResults];


/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Magnitude of the amount, in units of the currency, with a `.`.
     * @type {string}
     * @memberof Money
     */
    'amount': string;
    /**
     * Currency code for the amount.
     * @type {string}
     * @memberof Money
     */
    'currency': MoneyCurrencyEnum;
}

export const MoneyCurrencyEnum = {
    Usd: 'USD',
    Eur: 'EUR',
    Btc: 'BTC',
    Eth: 'ETH'
} as const;

export type MoneyCurrencyEnum = typeof MoneyCurrencyEnum[keyof typeof MoneyCurrencyEnum];

/**
 * 
 * @export
 * @interface NotAuthorized
 */
export interface NotAuthorized {
    /**
     * 
     * @type {number}
     * @memberof NotAuthorized
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof NotAuthorized
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * 
     * @type {number}
     * @memberof NotFound
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof NotFound
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PaymentCreationRequest
 */
export interface PaymentCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'idempotencyKey': string;
    /**
     * Universally unique identifier (UUID v4) of the public key used in encryption. NOTE the sandbox environment uses the default value of `key1`. For this reason the example supplied is `key1` rather than a UUID.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'keyId'?: string;
    /**
     * 
     * @type {MetadataPayment}
     * @memberof PaymentCreationRequest
     */
    'metadata': MetadataPayment;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PaymentCreationRequest
     */
    'amount': FiatMoneyUsd;
    /**
     * Triggers the automatic capture of the full payment amount. If set to false the payment will only be authorized but not captured.
     * @type {boolean}
     * @memberof PaymentCreationRequest
     */
    'autoCapture'?: boolean;
    /**
     * Indicates the verification method for this payment.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'verification': PaymentCreationRequestVerificationEnum;
    /**
     * The URL to redirect users to after successful 3DS authentication.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'verificationSuccessUrl'?: string;
    /**
     * The URL to redirect users to after failed 3DS authentication.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'verificationFailureUrl'?: string;
    /**
     * 
     * @type {Source}
     * @memberof PaymentCreationRequest
     */
    'source': Source;
    /**
     * Description of the payment with length restriction of 240 characters.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'description'?: string;
    /**
     * PGP encrypted base64 encoded string. Contains CVV. * **CVV (Card Verification Number)**: Three or four digit security code. Only required if `verification` is `cvv`. 
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'encryptedData'?: string;
    /**
     * The channel identifier that can be set for the payment. When not provided, the default channel is used.
     * @type {string}
     * @memberof PaymentCreationRequest
     */
    'channel'?: string;
}

export const PaymentCreationRequestVerificationEnum = {
    None: 'none',
    Cvv: 'cvv',
    ThreeDSecure: 'three_d_secure'
} as const;

export type PaymentCreationRequestVerificationEnum = typeof PaymentCreationRequestVerificationEnum[keyof typeof PaymentCreationRequestVerificationEnum];

/**
 * Indicates the failure reason of a payment. Only present for payments in failed state. Possible values are [`payment_failed`, `payment_fraud_detected`, `payment_denied`, `payment_not_supported_by_issuer`, `payment_not_funded`, `payment_unprocessable`, `payment_stopped_by_issuer`, `payment_canceled`, `payment_returned`, `payment_failed_balance_check`, `card_failed`, `card_invalid`, `card_address_mismatch`, `card_zip_mismatch`, `card_cvv_invalid`, `card_expired`, `card_limit_violated`, `card_not_honored`, `card_cvv_required`, `credit_card_not_allowed`, `card_account_ineligible`, `card_network_unsupported`, `channel_invalid`, `unauthorized_transaction`, `bank_account_ineligible`, `bank_transaction_error`, `invalid_account_number`, `invalid_wire_rtn`, `invalid_ach_rtn`, `vendor_inactive`]\'
 * @export
 * @enum {string}
 */

export const PaymentErrorCode = {
    PaymentFailed: 'payment_failed',
    PaymentFraudDetected: 'payment_fraud_detected',
    PaymentDenied: 'payment_denied',
    PaymentNotSupportedByIssuer: 'payment_not_supported_by_issuer',
    PaymentNotFunded: 'payment_not_funded',
    PaymentUnprocessable: 'payment_unprocessable',
    PaymentStoppedByIssuer: 'payment_stopped_by_issuer',
    PaymentCanceled: 'payment_canceled',
    PaymentReturned: 'payment_returned',
    PaymentFailedBalanceCheck: 'payment_failed_balance_check',
    CardFailed: 'card_failed',
    CardInvalid: 'card_invalid',
    CardAddressMismatch: 'card_address_mismatch',
    CardZipMismatch: 'card_zip_mismatch',
    CardCvvInvalid: 'card_cvv_invalid',
    CardExpired: 'card_expired',
    CardLimitViolated: 'card_limit_violated',
    CardNotHonored: 'card_not_honored',
    CardCvvRequired: 'card_cvv_required',
    CardRestricted: 'card_restricted,',
    CardAccountIneligible: 'card_account_ineligible',
    CardNetworkUnsupported: 'card_network_unsupported',
    ChannelInvalid: 'channel_invalid',
    UnauthorizedTransaction: 'unauthorized_transaction',
    BankAccountIneligible: 'bank_account_ineligible',
    BankTransactionError: 'bank_transaction_error',
    InvalidAccountNumber: 'invalid_account_number',
    InvalidWireRtn: 'invalid_wire_rtn',
    InvalidAchRtn: 'invalid_ach_rtn',
    RefIdInvalid: 'ref_id_invalid',
    AccountNameMismatch: 'account_name_mismatch',
    AccountNumberMismatch: 'account_number_mismatch',
    AccountIneligible: 'account_ineligible',
    WalletAddressMismatch: 'wallet_address_mismatch',
    CustomerNameMismatch: 'customer_name_mismatch',
    InstitutionNameMismatch: 'institution_name_mismatch',
    VendorInactive: 'vendor_inactive'
} as const;

export type PaymentErrorCode = typeof PaymentErrorCode[keyof typeof PaymentErrorCode];


/**
 * Status information of the related cancel. This property is only present on canceled payment or refund items.
 * @export
 * @interface PaymentInfoCancel
 */
export interface PaymentInfoCancel {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof PaymentInfoCancel
     */
    'id'?: string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof PaymentInfoCancel
     */
    'type'?: PaymentInfoCancelTypeEnum;
    /**
     * Enumerated description of the payment item.
     * @type {string}
     * @memberof PaymentInfoCancel
     */
    'description'?: PaymentInfoCancelDescriptionEnum;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof PaymentInfoCancel
     */
    'status'?: CancelRefundReversalStatus;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof PaymentInfoCancel
     */
    'createDate'?: string;
}

export const PaymentInfoCancelTypeEnum = {
    Cancel: 'cancel'
} as const;

export type PaymentInfoCancelTypeEnum = typeof PaymentInfoCancelTypeEnum[keyof typeof PaymentInfoCancelTypeEnum];
export const PaymentInfoCancelDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type PaymentInfoCancelDescriptionEnum = typeof PaymentInfoCancelDescriptionEnum[keyof typeof PaymentInfoCancelDescriptionEnum];

/**
 * Status information of the related payment. This property is only present on refund or cancel items.
 * @export
 * @interface PaymentInfoPaymentAndRefund
 */
export interface PaymentInfoPaymentAndRefund {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'id'?: string;
    /**
     * Type of the payment object.
     * @type {string}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'type'?: PaymentInfoPaymentAndRefundTypeEnum;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'amount'?: FiatMoneyUsd;
    /**
     * Enumerated description of the payment item.
     * @type {string}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'description'?: PaymentInfoPaymentAndRefundDescriptionEnum;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'status'?: PaymentStatus;
    /**
     * 
     * @type {RequiredAction}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'requiredAction'?: RequiredAction;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'fees'?: FiatMoneyUsd;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof PaymentInfoPaymentAndRefund
     */
    'createDate'?: string;
}

export const PaymentInfoPaymentAndRefundTypeEnum = {
    Payment: 'payment',
    Refund: 'refund'
} as const;

export type PaymentInfoPaymentAndRefundTypeEnum = typeof PaymentInfoPaymentAndRefundTypeEnum[keyof typeof PaymentInfoPaymentAndRefundTypeEnum];
export const PaymentInfoPaymentAndRefundDescriptionEnum = {
    Payment: 'Payment'
} as const;

export type PaymentInfoPaymentAndRefundDescriptionEnum = typeof PaymentInfoPaymentAndRefundDescriptionEnum[keyof typeof PaymentInfoPaymentAndRefundDescriptionEnum];

/**
 * Enumerated status of the payment. `pending` means the payment is waiting to be processed. `confirmed` means the payment has been approved by the bank and the merchant can treat it as successful, but settlement funds are not yet available to the merchant.  `paid` means settlement funds have been received and are available to the merchant. `failed` means something went wrong (most commonly that the payment was denied). `action_required` means that additional steps are required to process this payment; refer to `requiredAction` for more details. Terminal states are `paid` and `failed`.
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Pending: 'pending',
    Confirmed: 'confirmed',
    Paid: 'paid',
    Failed: 'failed',
    ActionRequired: 'action_required'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * Indicates the status of the payment verification. This property will be present once the payment is confirmed.
 * @export
 * @interface PaymentVerificationResponse
 */
export interface PaymentVerificationResponse {
    /**
     * Status of the AVS check. Raw AVS response, expressed as an upper-case letter. `not_requested` indicates check was not made. `pending` is pending/processing.
     * @type {string}
     * @memberof PaymentVerificationResponse
     */
    'avs': string;
    /**
     * 
     * @type {CvvResults}
     * @memberof PaymentVerificationResponse
     */
    'cvv': CvvResults;
    /**
     * 
     * @type {Model3dsResults}
     * @memberof PaymentVerificationResponse
     */
    'threeDSecure'?: Model3dsResults;
    /**
     * 
     * @type {Eci}
     * @memberof PaymentVerificationResponse
     */
    'eci'?: Eci;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Payout
     */
    'id'?: string;
    /**
     * The identifier of the source wallet used to fund a payout.
     * @type {string}
     * @memberof Payout
     */
    'sourceWalletId'?: string;
    /**
     * 
     * @type {BankDestination}
     * @memberof Payout
     */
    'destination'?: BankDestination;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Payout
     */
    'amount'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Payout
     */
    'fees'?: FiatMoneyUsd;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof Payout
     */
    'status'?: PayoutStatus;
    /**
     * A payout tracking reference. Will be present once known.
     * @type {any}
     * @memberof Payout
     */
    'trackingRef'?: any | null;
    /**
     * 
     * @type {PayoutErrorCode}
     * @memberof Payout
     */
    'errorCode'?: PayoutErrorCode | null;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof Payout
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * 
     * @type {PayoutBusinessAccountAdjustments}
     * @memberof Payout
     */
    'adjustments'?: PayoutBusinessAccountAdjustments | null;
    /**
     * 
     * @type {UnwithdrawalObject}
     * @memberof Payout
     */
    'return'?: UnwithdrawalObject | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Payout
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Payout
     */
    'updateDate'?: string;
}
/**
 * 
 * @export
 * @interface PayoutBusinessAccount
 */
export interface PayoutBusinessAccount {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof PayoutBusinessAccount
     */
    'id'?: string;
    /**
     * The identifier of the source wallet used to fund a payout.
     * @type {string}
     * @memberof PayoutBusinessAccount
     */
    'sourceWalletId'?: string;
    /**
     * 
     * @type {BankDestination}
     * @memberof PayoutBusinessAccount
     */
    'destination'?: BankDestination;
    /**
     * 
     * @type {FiatMoney}
     * @memberof PayoutBusinessAccount
     */
    'amount'?: FiatMoney;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PayoutBusinessAccount
     */
    'fees'?: FiatMoneyUsd;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutBusinessAccount
     */
    'status'?: PayoutStatus;
    /**
     * A payout tracking reference. Will be present once known.
     * @type {any}
     * @memberof PayoutBusinessAccount
     */
    'trackingRef'?: any | null;
    /**
     * 
     * @type {PayoutErrorCode}
     * @memberof PayoutBusinessAccount
     */
    'errorCode'?: PayoutErrorCode | null;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof PayoutBusinessAccount
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * 
     * @type {PayoutBusinessAccountAdjustments}
     * @memberof PayoutBusinessAccount
     */
    'adjustments'?: PayoutBusinessAccountAdjustments | null;
    /**
     * 
     * @type {UnwithdrawalObject}
     * @memberof PayoutBusinessAccount
     */
    'return'?: UnwithdrawalObject | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof PayoutBusinessAccount
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof PayoutBusinessAccount
     */
    'updateDate'?: string;
}
/**
 * Final adjustment which increases (credits) or decreases (debits) the total returned amount to the source wallet.
 * @export
 * @interface PayoutBusinessAccountAdjustments
 */
export interface PayoutBusinessAccountAdjustments {
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PayoutBusinessAccountAdjustments
     */
    'fxCredit'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PayoutBusinessAccountAdjustments
     */
    'fxDebit'?: FiatMoneyUsd;
}
/**
 * 
 * @export
 * @interface PayoutCreationRequest
 */
export interface PayoutCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof PayoutCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {WalletLocation}
     * @memberof PayoutCreationRequest
     */
    'source'?: WalletLocation;
    /**
     * 
     * @type {BankDestination}
     * @memberof PayoutCreationRequest
     */
    'destination': BankDestination;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof PayoutCreationRequest
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {MetadataPayout}
     * @memberof PayoutCreationRequest
     */
    'metadata': MetadataPayout;
}
/**
 * The destination bank account type.
 * @export
 * @enum {string}
 */

export const PayoutDestinationType = {
    Wire: 'wire',
    Ach: 'ach',
    Sepa: 'sepa'
} as const;

export type PayoutDestinationType = typeof PayoutDestinationType[keyof typeof PayoutDestinationType];


/**
 * Indicates the failure reason of a payout. Only present for payouts in failed state. Possible values are [`insufficient_funds`, `transaction_denied`, `transaction_failed`, `transaction_returned`, `bank_transaction_error`, `fiat_account_limit_exceeded`, `invalid_bank_account_number`, `invalid_ach_rtn`, `invalid_wire_rtn`, `vendor_inactive`]\'
 * @export
 * @enum {string}
 */

export const PayoutErrorCode = {
    InsufficientFunds: 'insufficient_funds',
    TransactionDenied: 'transaction_denied',
    TransactionFailed: 'transaction_failed',
    TransactionReturned: 'transaction_returned',
    BankTransactionError: 'bank_transaction_error',
    FiatAccountLimitExceeded: 'fiat_account_limit_exceeded',
    InvalidBankAccountNumber: 'invalid_bank_account_number',
    InvalidAchRtn: 'invalid_ach_rtn',
    InvalidWireRtn: 'invalid_wire_rtn',
    VendorInactive: 'vendor_inactive'
} as const;

export type PayoutErrorCode = typeof PayoutErrorCode[keyof typeof PayoutErrorCode];


/**
 * Status of the payout. Status `pending` indicates that the payout is in process; `complete` indicates it finished successfully; `failed` indicates it failed.
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * 
 * @export
 * @interface Ping
 */
export interface Ping {
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * Universally unique identifier (UUID v4) of the public key used in encryption. NOTE the sandbox environment uses the default value of `key1`. For this reason the example supplied is `key1` rather than a UUID.
     * @type {string}
     * @memberof PublicKey
     */
    'keyId': string;
    /**
     * A PGP ascii-armor encoded public key.
     * @type {string}
     * @memberof PublicKey
     */
    'publicKey': string;
}
/**
 * 
 * @export
 * @interface RefundCreationRequest
 */
export interface RefundCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof RefundCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof RefundCreationRequest
     */
    'amount': FiatMoneyUsd;
    /**
     * 
     * @type {ReversalReason}
     * @memberof RefundCreationRequest
     */
    'reason'?: ReversalReason;
}
/**
 * 
 * @export
 * @interface RefundPaymentResponse
 */
export interface RefundPaymentResponse {
    /**
     * 
     * @type {DetailedRefund}
     * @memberof RefundPaymentResponse
     */
    'data'?: DetailedRefund;
}
/**
 * When the payment status is `action_required`, this object summarizes the required additional steps.
 * @export
 * @interface RequiredAction
 */
export interface RequiredAction {
    /**
     * The type of action that is required to proceed with the payment. Currently only one type is supported.
     * @type {string}
     * @memberof RequiredAction
     */
    'type': RequiredActionTypeEnum;
    /**
     * The URL to bring the user to in order to complete the payment.
     * @type {string}
     * @memberof RequiredAction
     */
    'redirectUrl': string;
}

export const RequiredActionTypeEnum = {
    ThreeDSecureRequired: 'three_d_secure_required'
} as const;

export type RequiredActionTypeEnum = typeof RequiredActionTypeEnum[keyof typeof RequiredActionTypeEnum];

/**
 * 
 * @export
 * @interface Reversal
 */
export interface Reversal {
    /**
     * Universally unique identifier (UUID v4) of the public key used in encryption. NOTE the sandbox environment uses the default value of `key1`. For this reason the example supplied is `key1` rather than a UUID.
     * @type {string}
     * @memberof Reversal
     */
    'id': string;
    /**
     * Unique system generated identifier for the payment that is associated to the chargeback item.
     * @type {string}
     * @memberof Reversal
     */
    'paymentId': string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Reversal
     */
    'amount': FiatMoneyUsd;
    /**
     * Enumerated description of the payment.
     * @type {string}
     * @memberof Reversal
     */
    'description': string;
    /**
     * 
     * @type {CancelRefundReversalStatus}
     * @memberof Reversal
     */
    'status': CancelRefundReversalStatus;
    /**
     * 
     * @type {ReversalReason}
     * @memberof Reversal
     */
    'reason': ReversalReason;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Reversal
     */
    'fees': FiatMoneyUsd;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Reversal
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Reversal
     */
    'updateDate': string;
}
/**
 * Enumerated reason for a returned payment. Providing this reason in the request is recommended (to improve risk evaluation) but not required.
 * @export
 * @enum {string}
 */

export const ReversalReason = {
    Duplicate: 'duplicate',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    BankTransactionError: 'bank_transaction_error',
    InvalidAccountNumber: 'invalid_account_number',
    InsufficientFunds: 'insufficient_funds',
    PaymentStoppedByIssuer: 'payment_stopped_by_issuer',
    PaymentReturned: 'payment_returned',
    BankAccountIneligible: 'bank_account_ineligible',
    InvalidAchRtn: 'invalid_ach_rtn',
    UnauthorizedTransaction: 'unauthorized_transaction',
    PaymentFailed: 'payment_failed'
} as const;

export type ReversalReason = typeof ReversalReason[keyof typeof ReversalReason];


/**
 * Results of risk evaluation. Only present if the payment is denied by Circle\'s risk service.
 * @export
 * @interface RiskEvaluation
 */
export interface RiskEvaluation {
    /**
     * Enumerated decision of the account.
     * @type {string}
     * @memberof RiskEvaluation
     */
    'decision'?: RiskEvaluationDecisionEnum;
    /**
     * Risk reason for the definitive decision outcome.
     * @type {string}
     * @memberof RiskEvaluation
     */
    'reason'?: string | null;
}

export const RiskEvaluationDecisionEnum = {
    Approved: 'approved',
    Denied: 'denied',
    Review: 'review'
} as const;

export type RiskEvaluationDecisionEnum = typeof RiskEvaluationDecisionEnum[keyof typeof RiskEvaluationDecisionEnum];

/**
 * 
 * @export
 * @interface SEPA
 */
export interface SEPA {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SEPA
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof SEPA
     */
    'status': ExternalFiatAccountStatus;
    /**
     * Bank name plus last four digits of the IBAN.
     * @type {string}
     * @memberof SEPA
     */
    'description': string;
    /**
     * Tracking reference that needs to be set in the payment details or description.
     * @type {string}
     * @memberof SEPA
     */
    'trackingRef': string;
    /**
     * A UUID that uniquely identifies the account number. If the same account is used more than once, each card object will have a different id, but the fingerprint will stay the same.
     * @type {string}
     * @memberof SEPA
     */
    'fingerprint': string;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof SEPA
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * 
     * @type {BillingDetails}
     * @memberof SEPA
     */
    'billingDetails': BillingDetails;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SEPA
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SEPA
     */
    'updateDate': string;
}
/**
 * 
 * @export
 * @interface SEPACreationRequest
 */
export interface SEPACreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof SEPACreationRequest
     */
    'idempotencyKey': string;
    /**
     * International Bank Account Number (IBAN) for the bank account.
     * @type {string}
     * @memberof SEPACreationRequest
     */
    'iban': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof SEPACreationRequest
     */
    'billingDetails': BillingDetails;
}
/**
 * 
 * @export
 * @interface SEPAInstruction
 */
export interface SEPAInstruction {
    /**
     * Circle tracking reference that needs to be set in the SEPA transfer reference field.
     * @type {string}
     * @memberof SEPAInstruction
     */
    'trackingRef'?: string;
    /**
     * 
     * @type {SEPAInstructionBeneficiary}
     * @memberof SEPAInstruction
     */
    'beneficiary'?: SEPAInstructionBeneficiary;
    /**
     * 
     * @type {SEPAInstructionBeneficiaryBank}
     * @memberof SEPAInstruction
     */
    'beneficiaryBank'?: SEPAInstructionBeneficiaryBank;
}
/**
 * 
 * @export
 * @interface SEPAInstructionBeneficiary
 */
export interface SEPAInstructionBeneficiary {
    /**
     * Name of the beneficiary.
     * @type {string}
     * @memberof SEPAInstructionBeneficiary
     */
    'name'?: string;
    /**
     * Address line 1 of the beneficiary\'s address.
     * @type {string}
     * @memberof SEPAInstructionBeneficiary
     */
    'address1'?: string;
    /**
     * Address line 2 of the beneficiary\'s address.
     * @type {string}
     * @memberof SEPAInstructionBeneficiary
     */
    'address2'?: string;
}
/**
 * 
 * @export
 * @interface SEPAInstructionBeneficiaryBank
 */
export interface SEPAInstructionBeneficiaryBank {
    /**
     * Name of the beneficiary\'s bank.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'name'?: string;
    /**
     * BIC code of the beneficiary\'s bank account.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'bic'?: string;
    /**
     * IBAN of the beneficiary\'s bank account.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'iban'?: string;
    /**
     * Address of the beneficiary\'s bank.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'address'?: string;
    /**
     * City of the beneficiary\'s bank.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'city'?: string;
    /**
     * Postal code of the beneficiary\'s bank.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'postalCode'?: string;
    /**
     * Country code of the beneficiary\'s bank. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof SEPAInstructionBeneficiaryBank
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface SearchBusinessAccountDepositsResponse
 */
export interface SearchBusinessAccountDepositsResponse {
    /**
     * 
     * @type {Array<BusinessAccountDeposit>}
     * @memberof SearchBusinessAccountDepositsResponse
     */
    'data'?: Array<BusinessAccountDeposit>;
}
/**
 * 
 * @export
 * @interface SearchBusinessAccountTransfersResponse
 */
export interface SearchBusinessAccountTransfersResponse {
    /**
     * 
     * @type {Array<Transfer>}
     * @memberof SearchBusinessAccountTransfersResponse
     */
    'data'?: Array<Transfer>;
}
/**
 * 
 * @export
 * @interface SearchTransfersResponse
 */
export interface SearchTransfersResponse {
    /**
     * 
     * @type {Array<Transfer>}
     * @memberof SearchTransfersResponse
     */
    'data'?: Array<Transfer>;
}
/**
 * 
 * @export
 * @interface SenFiatAccountCreationRequest
 */
export interface SenFiatAccountCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof SenFiatAccountCreationRequest
     */
    'idempotencyKey': string;
    /**
     * Silvergate SEN account number.
     * @type {string}
     * @memberof SenFiatAccountCreationRequest
     */
    'accountNumber': string;
    /**
     * Currency of the Silvergate SEN account.
     * @type {string}
     * @memberof SenFiatAccountCreationRequest
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface SenFiatAccountResponse
 */
export interface SenFiatAccountResponse {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof SenFiatAccountResponse
     */
    'status': ExternalFiatAccountStatus;
    /**
     * Bank name plus last four digits of the bank account number.
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'description': string;
    /**
     * Circle tracking reference that needs to be set in the memo field..
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'trackingRef': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'updateDate': string;
    /**
     * Currency of the fiat account.
     * @type {string}
     * @memberof SenFiatAccountResponse
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface SenInstruction
 */
export interface SenInstruction {
    /**
     * Circle tracking reference that needs to be set in the memo field.
     * @type {string}
     * @memberof SenInstruction
     */
    'trackingRef'?: string;
    /**
     * Circle corporate Silvergate SEN account number that needs to be set as destination.
     * @type {string}
     * @memberof SenInstruction
     */
    'accountNumber'?: string;
    /**
     * Currency of Circle corporate Silvergate SEN account.
     * @type {string}
     * @memberof SenInstruction
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface Settlement
 */
export interface Settlement {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Settlement
     */
    'id'?: string;
    /**
     * Unique system generated identifier for the wallet of the merchant.
     * @type {string}
     * @memberof Settlement
     */
    'merchantWalletId'?: string;
    /**
     * If this settlement was used for a marketplace payment, the wallet involved in the settlement. Not included for standard merchant settlements.
     * @type {string}
     * @memberof Settlement
     */
    'walletId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Settlement
     */
    'totalDebits'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Settlement
     */
    'totalCredits'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Settlement
     */
    'paymentFees'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof Settlement
     */
    'chargebackFees'?: FiatMoneyUsd;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Settlement
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Settlement
     */
    'updateDate'?: string;
}
/**
 * 
 * @export
 * @interface SignetFiatAccountCreationRequest
 */
export interface SignetFiatAccountCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof SignetFiatAccountCreationRequest
     */
    'idempotencyKey': string;
    /**
     * Signet wallet address.
     * @type {string}
     * @memberof SignetFiatAccountCreationRequest
     */
    'walletAddress': string;
}
/**
 * 
 * @export
 * @interface SignetFiatAccountResponse
 */
export interface SignetFiatAccountResponse {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SignetFiatAccountResponse
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof SignetFiatAccountResponse
     */
    'status': ExternalFiatAccountStatus;
    /**
     * Tracking ref that needs to be set in the public description field when you send the funds to Circle Signet wallet.
     * @type {string}
     * @memberof SignetFiatAccountResponse
     */
    'trackingRef': string;
    /**
     * Your signet wallet address.
     * @type {string}
     * @memberof SignetFiatAccountResponse
     */
    'walletAddress': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SignetFiatAccountResponse
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SignetFiatAccountResponse
     */
    'updateDate': string;
}
/**
 * 
 * @export
 * @interface SignetInstruction
 */
export interface SignetInstruction {
    /**
     * Circle tracking reference that needs to be set in the signet public description field.
     * @type {string}
     * @memberof SignetInstruction
     */
    'trackingRef'?: string;
    /**
     * Circle wallet address that needs to be set in the signet recipient wallet field.
     * @type {string}
     * @memberof SignetInstruction
     */
    'walletAddress'?: string;
}
/**
 * Billing details of the card holder.
 * @export
 * @interface SimpleBillingDetails
 */
export interface SimpleBillingDetails {
    /**
     * Country portion of the address. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof SimpleBillingDetails
     */
    'country': string;
    /**
     * State / County / Province / Region portion of the address. US and Canada use the two-letter code for the subdivision.
     * @type {string}
     * @memberof SimpleBillingDetails
     */
    'district': string;
}
/**
 * 
 * @export
 * @interface SimpleCard
 */
export interface SimpleCard {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SimpleCard
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof SimpleCard
     */
    'status': ExternalFiatAccountStatus;
    /**
     * 
     * @type {SimpleBillingDetails}
     * @memberof SimpleCard
     */
    'billingDetails': SimpleBillingDetails;
    /**
     * Two digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof SimpleCard
     */
    'expMonth': number;
    /**
     * Four digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof SimpleCard
     */
    'expYear': number;
    /**
     * The network of the card.
     * @type {string}
     * @memberof SimpleCard
     */
    'network': SimpleCardNetworkEnum;
    /**
     * The bank identification number (BIN), the first 6 digits of the card.
     * @type {string}
     * @memberof SimpleCard
     */
    'bin'?: string;
    /**
     * The country code of the issuer bank. Follows the ISO 3166-1 alpha-2 standard.
     * @type {string}
     * @memberof SimpleCard
     */
    'issuerCountry'?: string;
    /**
     * A UUID that uniquely identifies the account number. If the same account is used more than once, each card object will have a different id, but the fingerprint will stay the same.
     * @type {string}
     * @memberof SimpleCard
     */
    'fingerprint': string;
    /**
     * 
     * @type {CardVerificationResponse}
     * @memberof SimpleCard
     */
    'verification': CardVerificationResponse;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof SimpleCard
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SimpleCard
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof SimpleCard
     */
    'updateDate': string;
}

export const SimpleCardNetworkEnum = {
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    Amex: 'AMEX',
    Unknown: 'UNKNOWN'
} as const;

export type SimpleCardNetworkEnum = typeof SimpleCardNetworkEnum[keyof typeof SimpleCardNetworkEnum];

/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Type of the source.
     * @type {string}
     * @memberof Source
     */
    'type'?: SourceTypeEnum;
}

export const SourceTypeEnum = {
    Card: 'card',
    Ach: 'ach'
} as const;

export type SourceTypeEnum = typeof SourceTypeEnum[keyof typeof SourceTypeEnum];

/**
 * The payment source.
 * @export
 * @interface SourceResponse
 */
export interface SourceResponse {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SourceResponse
     */
    'id'?: string;
    /**
     * Type of the source.
     * @type {string}
     * @memberof SourceResponse
     */
    'type'?: SourceResponseTypeEnum;
}

export const SourceResponseTypeEnum = {
    Card: 'card',
    Ach: 'ach',
    Wire: 'wire',
    Sepa: 'sepa'
} as const;

export type SourceResponseTypeEnum = typeof SourceResponseTypeEnum[keyof typeof SourceResponseTypeEnum];

/**
 * 
 * @export
 * @interface Stablecoin
 */
export interface Stablecoin {
    /**
     * Name of the stablecoin.
     * @type {string}
     * @memberof Stablecoin
     */
    'name'?: string;
    /**
     * Symbol of the stablecoin.
     * @type {string}
     * @memberof Stablecoin
     */
    'symbol'?: string;
    /**
     * Total circulating amount of the stablecoin.
     * @type {string}
     * @memberof Stablecoin
     */
    'totalAmount'?: string;
    /**
     * A list of the broken down totalAmount by chain of the stablecoin.
     * @type {Array<TokenAmount>}
     * @memberof Stablecoin
     */
    'chains'?: Array<TokenAmount>;
}
/**
 * 
 * @export
 * @interface SubscribeResponse
 */
export interface SubscribeResponse {
    /**
     * 
     * @type {SubscriptionResponse}
     * @memberof SubscribeResponse
     */
    'data'?: SubscriptionResponse;
}
/**
 * 
 * @export
 * @interface SubscriptionDetail
 */
export interface SubscriptionDetail {
    /**
     * Identifier for created subscription.
     * @type {string}
     * @memberof SubscriptionDetail
     */
    'url'?: string;
    /**
     * Status of the subscription request.
     * @type {string}
     * @memberof SubscriptionDetail
     */
    'status'?: SubscriptionDetailStatusEnum;
}

export const SubscriptionDetailStatusEnum = {
    Confirmed: 'confirmed',
    Pending: 'pending',
    Deleted: 'deleted'
} as const;

export type SubscriptionDetailStatusEnum = typeof SubscriptionDetailStatusEnum[keyof typeof SubscriptionDetailStatusEnum];

/**
 * 
 * @export
 * @interface SubscriptionRequest
 */
export interface SubscriptionRequest {
    /**
     * URL of the subscriber endpoint. Must be publicly accessible and utilize HTTPS.
     * @type {string}
     * @memberof SubscriptionRequest
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface SubscriptionResponse
 */
export interface SubscriptionResponse {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'id'?: string;
    /**
     * URL of the endpoint.
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'endpoint'?: string;
    /**
     * List of subscriptions details for created subscriptions.
     * @type {Array<SubscriptionDetail>}
     * @memberof SubscriptionResponse
     */
    'subscriptionDetails'?: Array<SubscriptionDetail>;
}
/**
 * 
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
    /**
     * Magnitude of the amount, in units of the currency, with a `.`.
     * @type {string}
     * @memberof TokenAmount
     */
    'amount': string;
    /**
     * 
     * @type {Chain}
     * @memberof TokenAmount
     */
    'chain': Chain;
}
/**
 * A transfer of funds.
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Transfer
     */
    'id': string;
    /**
     * 
     * @type {TransferSourceLocation}
     * @memberof Transfer
     */
    'source': TransferSourceLocation;
    /**
     * 
     * @type {TransferDestinationLocation}
     * @memberof Transfer
     */
    'destination': TransferDestinationLocation;
    /**
     * 
     * @type {Money}
     * @memberof Transfer
     */
    'amount': Money;
    /**
     * A hash that uniquely identifies the onchain transaction. This is only available where either source or destination are of type blockchain.
     * @type {string}
     * @memberof Transfer
     */
    'transactionHash'?: string;
    /**
     * Status of the transfer. Status `pending` indicates that the transfer is in the process of running; `complete` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof Transfer
     */
    'status': TransferStatusEnum;
    /**
     * 
     * @type {TransferErrorCode}
     * @memberof Transfer
     */
    'errorCode'?: TransferErrorCode | null;
    /**
     * The create date of the transfer.
     * @type {string}
     * @memberof Transfer
     */
    'createDate'?: string;
}

export const TransferStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type TransferStatusEnum = typeof TransferStatusEnum[keyof typeof TransferStatusEnum];

/**
 * 
 * @export
 * @interface TransferCreationRequest
 */
export interface TransferCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof TransferCreationRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {TransferRequestSourceWalletLocation}
     * @memberof TransferCreationRequest
     */
    'source': TransferRequestSourceWalletLocation;
    /**
     * 
     * @type {TransferCreationRequestDestination}
     * @memberof TransferCreationRequest
     */
    'destination': TransferCreationRequestDestination;
    /**
     * 
     * @type {Money}
     * @memberof TransferCreationRequest
     */
    'amount': Money;
}
/**
 * @type TransferCreationRequestDestination
 * @export
 */
export type TransferCreationRequestDestination = TransferRequestBlockchainLocation | WalletLocation;

/**
 * A destination blockchain address.
 * @export
 * @interface TransferDestinationBlockchainLocation
 */
export interface TransferDestinationBlockchainLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferDestinationBlockchainLocation
     */
    'type': TransferDestinationBlockchainLocationTypeEnum;
    /**
     * An alphanumeric string representing a blockchain address. Will be in different formats for different chains. It is important to preserve the exact formatting and capitalization of the address.
     * @type {string}
     * @memberof TransferDestinationBlockchainLocation
     */
    'address': string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof TransferDestinationBlockchainLocation
     */
    'addressTag'?: string | null;
    /**
     * 
     * @type {Chain}
     * @memberof TransferDestinationBlockchainLocation
     */
    'chain': Chain;
}

export const TransferDestinationBlockchainLocationTypeEnum = {
    Blockchain: 'blockchain'
} as const;

export type TransferDestinationBlockchainLocationTypeEnum = typeof TransferDestinationBlockchainLocationTypeEnum[keyof typeof TransferDestinationBlockchainLocationTypeEnum];

/**
 * @type TransferDestinationLocation
 * A destination of funds.
 * @export
 */
export type TransferDestinationLocation = TransferDestinationBlockchainLocation | TransferDestinationWalletLocation;

/**
 * A destination wallet location.
 * @export
 * @interface TransferDestinationWalletLocation
 */
export interface TransferDestinationWalletLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferDestinationWalletLocation
     */
    'type': TransferDestinationWalletLocationTypeEnum;
    /**
     * The id of the wallet.
     * @type {string}
     * @memberof TransferDestinationWalletLocation
     */
    'id': string;
    /**
     * An alphanumeric string which indicates the wallet address used to receive the transfer. Will only be set when the transfer source is a blockchain address.
     * @type {string}
     * @memberof TransferDestinationWalletLocation
     */
    'address'?: string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof TransferDestinationWalletLocation
     */
    'addressTag'?: string | null;
}

export const TransferDestinationWalletLocationTypeEnum = {
    Wallet: 'wallet'
} as const;

export type TransferDestinationWalletLocationTypeEnum = typeof TransferDestinationWalletLocationTypeEnum[keyof typeof TransferDestinationWalletLocationTypeEnum];

/**
 * A transfer of funds.
 * @export
 * @interface TransferDetailedTransfer
 */
export interface TransferDetailedTransfer {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof TransferDetailedTransfer
     */
    'id': string;
    /**
     * 
     * @type {TransferSourceLocation}
     * @memberof TransferDetailedTransfer
     */
    'source': TransferSourceLocation;
    /**
     * 
     * @type {TransferDestinationLocation}
     * @memberof TransferDetailedTransfer
     */
    'destination': TransferDestinationLocation;
    /**
     * 
     * @type {Money}
     * @memberof TransferDetailedTransfer
     */
    'amount': Money;
    /**
     * A hash that uniquely identifies the onchain transaction. This is only available where either source or destination are of type blockchain.
     * @type {string}
     * @memberof TransferDetailedTransfer
     */
    'transactionHash'?: string;
    /**
     * Status of the transfer. Status `pending` indicates that the transfer is in the process of running; `complete` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof TransferDetailedTransfer
     */
    'status': TransferDetailedTransferStatusEnum;
    /**
     * 
     * @type {TransferErrorCode}
     * @memberof TransferDetailedTransfer
     */
    'errorCode'?: TransferErrorCode | null;
    /**
     * 
     * @type {RiskEvaluation}
     * @memberof TransferDetailedTransfer
     */
    'riskEvaluation'?: RiskEvaluation | null;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof TransferDetailedTransfer
     */
    'createDate'?: string;
}

export const TransferDetailedTransferStatusEnum = {
    Failed: 'failed',
    Pending: 'pending',
    Complete: 'complete'
} as const;

export type TransferDetailedTransferStatusEnum = typeof TransferDetailedTransferStatusEnum[keyof typeof TransferDetailedTransferStatusEnum];

/**
 * Indicates the failure reason of a transfer. Only present for transfers in a `failed` state. Possible values are `insufficient_funds`, `blockchain_error` and `transfer_denied` and `transfer_failed`
 * @export
 * @enum {string}
 */

export const TransferErrorCode = {
    TransferFailed: 'transfer_failed',
    TransferDenied: 'transfer_denied',
    BlockchainError: 'blockchain_error',
    InsufficientFunds: 'insufficient_funds'
} as const;

export type TransferErrorCode = typeof TransferErrorCode[keyof typeof TransferErrorCode];


/**
 * 
 * @export
 * @interface TransferRequestBlockchainLocation
 */
export interface TransferRequestBlockchainLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferRequestBlockchainLocation
     */
    'type': TransferRequestBlockchainLocationTypeEnum;
    /**
     * The blockchain address.
     * @type {string}
     * @memberof TransferRequestBlockchainLocation
     */
    'address': string;
    /**
     * The secondary identifier for a blockchain address. An example of this is the memo field on the Stellar network, which can be text, id, or hash format.
     * @type {string}
     * @memberof TransferRequestBlockchainLocation
     */
    'addressTag'?: string | null;
    /**
     * 
     * @type {Chain}
     * @memberof TransferRequestBlockchainLocation
     */
    'chain': Chain;
}

export const TransferRequestBlockchainLocationTypeEnum = {
    Blockchain: 'blockchain'
} as const;

export type TransferRequestBlockchainLocationTypeEnum = typeof TransferRequestBlockchainLocationTypeEnum[keyof typeof TransferRequestBlockchainLocationTypeEnum];

/**
 * 
 * @export
 * @interface TransferRequestSourceWalletLocation
 */
export interface TransferRequestSourceWalletLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferRequestSourceWalletLocation
     */
    'type': TransferRequestSourceWalletLocationTypeEnum;
    /**
     * The id of the wallet.
     * @type {string}
     * @memberof TransferRequestSourceWalletLocation
     */
    'id': string;
    /**
     * 
     * @type {Array<Identity>}
     * @memberof TransferRequestSourceWalletLocation
     */
    'identities'?: Array<Identity>;
}

export const TransferRequestSourceWalletLocationTypeEnum = {
    Wallet: 'wallet'
} as const;

export type TransferRequestSourceWalletLocationTypeEnum = typeof TransferRequestSourceWalletLocationTypeEnum[keyof typeof TransferRequestSourceWalletLocationTypeEnum];

/**
 * 
 * @export
 * @interface TransferRequestVerifiedBlockchainLocation
 */
export interface TransferRequestVerifiedBlockchainLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferRequestVerifiedBlockchainLocation
     */
    'type': TransferRequestVerifiedBlockchainLocationTypeEnum;
    /**
     * The ID of the verified blockchain recipient address.
     * @type {string}
     * @memberof TransferRequestVerifiedBlockchainLocation
     */
    'addressId': string;
}

export const TransferRequestVerifiedBlockchainLocationTypeEnum = {
    VerifiedBlockchain: 'verified_blockchain'
} as const;

export type TransferRequestVerifiedBlockchainLocationTypeEnum = typeof TransferRequestVerifiedBlockchainLocationTypeEnum[keyof typeof TransferRequestVerifiedBlockchainLocationTypeEnum];

/**
 * A source blockchain address.
 * @export
 * @interface TransferSourceBlockchainLocation
 */
export interface TransferSourceBlockchainLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferSourceBlockchainLocation
     */
    'type': TransferSourceBlockchainLocationTypeEnum;
    /**
     * 
     * @type {Chain}
     * @memberof TransferSourceBlockchainLocation
     */
    'chain': Chain;
    /**
     * 
     * @type {Array<Identity>}
     * @memberof TransferSourceBlockchainLocation
     */
    'identities'?: Array<Identity>;
}

export const TransferSourceBlockchainLocationTypeEnum = {
    Blockchain: 'blockchain'
} as const;

export type TransferSourceBlockchainLocationTypeEnum = typeof TransferSourceBlockchainLocationTypeEnum[keyof typeof TransferSourceBlockchainLocationTypeEnum];

/**
 * @type TransferSourceLocation
 * A source of funds.
 * @export
 */
export type TransferSourceLocation = TransferSourceBlockchainLocation | TransferSourceWalletLocation;

/**
 * A source wallet location.
 * @export
 * @interface TransferSourceWalletLocation
 */
export interface TransferSourceWalletLocation {
    /**
     * 
     * @type {string}
     * @memberof TransferSourceWalletLocation
     */
    'type': TransferSourceWalletLocationTypeEnum;
    /**
     * The id of the wallet.
     * @type {string}
     * @memberof TransferSourceWalletLocation
     */
    'id': string;
    /**
     * 
     * @type {Array<Identity>}
     * @memberof TransferSourceWalletLocation
     */
    'identities'?: Array<Identity>;
}

export const TransferSourceWalletLocationTypeEnum = {
    Wallet: 'wallet'
} as const;

export type TransferSourceWalletLocationTypeEnum = typeof TransferSourceWalletLocationTypeEnum[keyof typeof TransferSourceWalletLocationTypeEnum];

/**
 * Return information if the payout is returned by bank. Only present if `errorCode` of payout is `transaction_returned`.
 * @export
 * @interface UnwithdrawalObject
 */
export interface UnwithdrawalObject {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'id'?: string;
    /**
     * Universally unique identifier (UUID v4) of the payout that is associated with the return.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'payoutId'?: string;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof UnwithdrawalObject
     */
    'amount'?: FiatMoneyUsd;
    /**
     * 
     * @type {FiatMoneyUsd}
     * @memberof UnwithdrawalObject
     */
    'fees'?: FiatMoneyUsd;
    /**
     * Reason for the return.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'reason'?: string;
    /**
     * Status of the return. A `pending` status indicates that the return is in process; `complete` indicates it finished successfully; `failed` indicates it failed.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'status'?: UnwithdrawalObjectStatusEnum;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'createDate'?: string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof UnwithdrawalObject
     */
    'updateDate'?: string;
}

export const UnwithdrawalObjectStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
} as const;

export type UnwithdrawalObjectStatusEnum = typeof UnwithdrawalObjectStatusEnum[keyof typeof UnwithdrawalObjectStatusEnum];

/**
 * 
 * @export
 * @interface UpdateCardResponse
 */
export interface UpdateCardResponse {
    /**
     * 
     * @type {Card}
     * @memberof UpdateCardResponse
     */
    'data'?: Card;
}
/**
 * Indicates the failure reason of the card verification. Only present on cards with failed verification. Possible values are [verification_failed, verification_fraud_detected, verification_denied, verification_not_supported_by_issuer, verification_stopped_by_issuer, card_failed, card_invalid, card_address_mismatch, card_zip_mismatch, card_cvv_invalid, card_expired, card_limit_violated, card_not_honored, card_cvv_required, credit_card_not_allowed, card_account_ineligible, card_network_unsupported]\'
 * @export
 * @enum {string}
 */

export const VerificationErrorCode = {
    VerificationFailed: 'verification_failed',
    VerificationFraudDetected: 'verification_fraud_detected',
    VerificationDenied: 'verification_denied',
    VerificationNotSupportedByIssuer: 'verification_not_supported_by_issuer',
    VerificationStoppedByIssuer: 'verification_stopped_by_issuer',
    CardFailed: 'card_failed',
    CardInvalid: 'card_invalid',
    CardAddressMismatch: 'card_address_mismatch',
    CardZipMismatch: 'card_zip_mismatch',
    CardCvvInvalid: 'card_cvv_invalid',
    CardExpired: 'card_expired',
    CardLimitViolated: 'card_limit_violated',
    CardNotHonored: 'card_not_honored',
    CardCvvRequired: 'card_cvv_required',
    CreditCardNotAllowed: 'credit_card_not_allowed',
    CardAccountIneligible: 'card_account_ineligible',
    CardNetworkUnsupported: 'card_network_unsupported'
} as const;

export type VerificationErrorCode = typeof VerificationErrorCode[keyof typeof VerificationErrorCode];


/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * Wallet identifier. Numeric value but should be treated as a string as format may change in the future\'
     * @type {string}
     * @memberof Wallet
     */
    'walletId'?: string;
    /**
     * Universally unique identifier (UUID v4) of the entity that owns the wallet.
     * @type {string}
     * @memberof Wallet
     */
    'entityId'?: string;
    /**
     * Wallet type.
     * @type {string}
     * @memberof Wallet
     */
    'type'?: WalletTypeEnum;
    /**
     * A human-friendly, non-unique identifier for a wallet.
     * @type {string}
     * @memberof Wallet
     */
    'description'?: string;
    /**
     * A list of balances for currencies owned by the wallet.
     * @type {Array<Money>}
     * @memberof Wallet
     */
    'balances'?: Array<Money>;
}

export const WalletTypeEnum = {
    EndUserWallet: 'end_user_wallet'
} as const;

export type WalletTypeEnum = typeof WalletTypeEnum[keyof typeof WalletTypeEnum];

/**
 * 
 * @export
 * @interface WalletCreationRequest
 */
export interface WalletCreationRequest {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof WalletCreationRequest
     */
    'idempotencyKey': string;
    /**
     * A human-friendly, non-unique identifier for a wallet.
     * @type {string}
     * @memberof WalletCreationRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface WalletLocation
 */
export interface WalletLocation {
    /**
     * 
     * @type {string}
     * @memberof WalletLocation
     */
    'type': WalletLocationTypeEnum;
    /**
     * The id of the wallet.
     * @type {string}
     * @memberof WalletLocation
     */
    'id': string;
}

export const WalletLocationTypeEnum = {
    Wallet: 'wallet'
} as const;

export type WalletLocationTypeEnum = typeof WalletLocationTypeEnum[keyof typeof WalletLocationTypeEnum];

/**
 * 
 * @export
 * @interface Wire
 */
export interface Wire {
    /**
     * Unique system generated identifier for the entity.
     * @type {string}
     * @memberof Wire
     */
    'id': string;
    /**
     * 
     * @type {ExternalFiatAccountStatus}
     * @memberof Wire
     */
    'status': ExternalFiatAccountStatus;
    /**
     * Bank name plus last four digits of the bank account number or IBAN.
     * @type {string}
     * @memberof Wire
     */
    'description': string;
    /**
     * Wire tracking ref that needs to be set in the wire reference to beneficiary field.
     * @type {string}
     * @memberof Wire
     */
    'trackingRef': string;
    /**
     * A UUID that uniquely identifies the account number. If the same account is used more than once, each card object will have a different id, but the fingerprint will stay the same.
     * @type {string}
     * @memberof Wire
     */
    'fingerprint': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof Wire
     */
    'billingDetails': BillingDetails;
    /**
     * 
     * @type {BankAddress}
     * @memberof Wire
     */
    'bankAddress'?: BankAddress;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Wire
     */
    'createDate': string;
    /**
     * ISO-8601 UTC date/time format.
     * @type {string}
     * @memberof Wire
     */
    'updateDate': string;
}
/**
 * @type WireCreationRequest
 * Request object used to create a bank account (wires). Different fields are required depending on the bank country, see the guide documentation for the list of supported bank countries along with which ones support IBAN.
 * @export
 */
export type WireCreationRequest = WireCreationRequestAccountNumber | WireCreationRequestIban | WireCreationRequestUS;

/**
 * Relevant fields for non-U.S. banks that do NOT support IBAN.
 * @export
 * @interface WireCreationRequestAccountNumber
 */
export interface WireCreationRequestAccountNumber {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof WireCreationRequestAccountNumber
     */
    'idempotencyKey': string;
    /**
     * Account number that identifies the bank account.
     * @type {string}
     * @memberof WireCreationRequestAccountNumber
     */
    'accountNumber': string;
    /**
     * The bank\'s SWIFT / BIC code.
     * @type {string}
     * @memberof WireCreationRequestAccountNumber
     */
    'routingNumber': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof WireCreationRequestAccountNumber
     */
    'billingDetails': BillingDetails;
    /**
     * 
     * @type {BankAddressNonIban}
     * @memberof WireCreationRequestAccountNumber
     */
    'bankAddress': BankAddressNonIban;
}
/**
 * Relevant fields for non-U.S. bank accounts that support IBAN.
 * @export
 * @interface WireCreationRequestIban
 */
export interface WireCreationRequestIban {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof WireCreationRequestIban
     */
    'idempotencyKey': string;
    /**
     * International Bank Account Number (IBAN) for the bank account.
     * @type {string}
     * @memberof WireCreationRequestIban
     */
    'iban': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof WireCreationRequestIban
     */
    'billingDetails': BillingDetails;
    /**
     * 
     * @type {BankAddressIbanSupported}
     * @memberof WireCreationRequestIban
     */
    'bankAddress': BankAddressIbanSupported;
}
/**
 * Relevant fields for U.S. bank accounts.
 * @export
 * @interface WireCreationRequestUS
 */
export interface WireCreationRequestUS {
    /**
     * Universally unique identifier (UUID v4) idempotency key. This key is utilized to ensure exactly-once execution of mutating requests.
     * @type {string}
     * @memberof WireCreationRequestUS
     */
    'idempotencyKey': string;
    /**
     * Account number that identifies the bank account.
     * @type {string}
     * @memberof WireCreationRequestUS
     */
    'accountNumber': string;
    /**
     * ABA routing number for the bank account. Note this has to be specific for bank wire transfers.
     * @type {string}
     * @memberof WireCreationRequestUS
     */
    'routingNumber': string;
    /**
     * 
     * @type {BillingDetails}
     * @memberof WireCreationRequestUS
     */
    'billingDetails': BillingDetails;
    /**
     * 
     * @type {BankAddress}
     * @memberof WireCreationRequestUS
     */
    'bankAddress': BankAddress;
}
/**
 * 
 * @export
 * @interface WireInstruction
 */
export interface WireInstruction {
    /**
     * Circle tracking reference that needs to be set in the wire reference field.
     * @type {string}
     * @memberof WireInstruction
     */
    'trackingRef'?: string;
    /**
     * 
     * @type {WireInstructionBeneficiary}
     * @memberof WireInstruction
     */
    'beneficiary'?: WireInstructionBeneficiary;
    /**
     * 
     * @type {WireInstructionBeneficiaryBank}
     * @memberof WireInstruction
     */
    'beneficiaryBank'?: WireInstructionBeneficiaryBank;
}
/**
 * 
 * @export
 * @interface WireInstructionBeneficiary
 */
export interface WireInstructionBeneficiary {
    /**
     * Name of the beneficiary.
     * @type {string}
     * @memberof WireInstructionBeneficiary
     */
    'name'?: string;
    /**
     * Address line 1 of the beneficiary\'s address.
     * @type {string}
     * @memberof WireInstructionBeneficiary
     */
    'address1'?: string;
    /**
     * Address line 2 of the beneficiary\'s address.
     * @type {string}
     * @memberof WireInstructionBeneficiary
     */
    'address2'?: string;
}
/**
 * 
 * @export
 * @interface WireInstructionBeneficiaryBank
 */
export interface WireInstructionBeneficiaryBank {
    /**
     * Name of the beneficiary\'s bank.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'name'?: string;
    /**
     * SWIFT code of the beneficiary\'s bank account.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'swiftCode'?: string;
    /**
     * ABA Routing number of the beneficiary\'s bank account.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'routingNumber'?: string;
    /**
     * Account number of the beneficiary\'s bank account.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'accountNumber'?: string;
    /**
     * Currency of the beneficiary\'s bank account.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'currency'?: string;
    /**
     * Address of the beneficiary\'s bank.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'address'?: string;
    /**
     * City of the beneficiary\'s bank.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'city'?: string;
    /**
     * Postal code of the beneficiary\'s bank.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'postalCode'?: string;
    /**
     * Country code of the beneficiary\'s bank. Formatted as a two-letter country code specified in ISO 3166-1 alpha-2.
     * @type {string}
     * @memberof WireInstructionBeneficiaryBank
     */
    'country'?: string;
}

/**
 * ACHApi - axios parameter creator
 * @export
 */
export const ACHApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ACH bank account
         * @param {ACHCreationRequest} [aCHCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACHBankAccount: async (aCHCreationRequest?: ACHCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/banks/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCHCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In the sandbox environment, create a mock ACH account and retrieve a processor token that can be used to link an ACH account.
         * @summary Create a mock ACH bank account
         * @param {MockAchAccountCreationRequest} [mockAchAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAchAccount: async (mockAchAccountCreationRequest?: MockAchAccountCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mocks/ach/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockAchAccountCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a ACH bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACHBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getACHBankAccount', 'id', id)
            const localVarPath = `/v1/banks/ach/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ACHApi - functional programming interface
 * @export
 */
export const ACHApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ACHApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ACH bank account
         * @param {ACHCreationRequest} [aCHCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createACHBankAccount(aCHCreationRequest?: ACHCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateACHBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createACHBankAccount(aCHCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In the sandbox environment, create a mock ACH account and retrieve a processor token that can be used to link an ACH account.
         * @summary Create a mock ACH bank account
         * @param {MockAchAccountCreationRequest} [mockAchAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAchAccount(mockAchAccountCreationRequest?: MockAchAccountCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAchAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAchAccount(mockAchAccountCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a ACH bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getACHBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetACHBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getACHBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ACHApi - factory interface
 * @export
 */
export const ACHApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ACHApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ACH bank account
         * @param {ACHCreationRequest} [aCHCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACHBankAccount(aCHCreationRequest?: ACHCreationRequest, options?: any): AxiosPromise<CreateACHBankAccountResponse> {
            return localVarFp.createACHBankAccount(aCHCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * In the sandbox environment, create a mock ACH account and retrieve a processor token that can be used to link an ACH account.
         * @summary Create a mock ACH bank account
         * @param {MockAchAccountCreationRequest} [mockAchAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAchAccount(mockAchAccountCreationRequest?: MockAchAccountCreationRequest, options?: any): AxiosPromise<CreateAchAccountResponse> {
            return localVarFp.createAchAccount(mockAchAccountCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a ACH bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACHBankAccount(id: string, options?: any): AxiosPromise<GetACHBankAccountResponse> {
            return localVarFp.getACHBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ACHApi - object-oriented interface
 * @export
 * @class ACHApi
 * @extends {BaseAPI}
 */
export class ACHApi extends BaseAPI {
    /**
     * 
     * @summary Create a ACH bank account
     * @param {ACHCreationRequest} [aCHCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHApi
     */
    public createACHBankAccount(aCHCreationRequest?: ACHCreationRequest, options?: AxiosRequestConfig) {
        return ACHApiFp(this.configuration).createACHBankAccount(aCHCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In the sandbox environment, create a mock ACH account and retrieve a processor token that can be used to link an ACH account.
     * @summary Create a mock ACH bank account
     * @param {MockAchAccountCreationRequest} [mockAchAccountCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHApi
     */
    public createAchAccount(mockAchAccountCreationRequest?: MockAchAccountCreationRequest, options?: AxiosRequestConfig) {
        return ACHApiFp(this.configuration).createAchAccount(mockAchAccountCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a ACH bank account
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHApi
     */
    public getACHBankAccount(id: string, options?: AxiosRequestConfig) {
        return ACHApiFp(this.configuration).getACHBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. 
         * @summary Create a recipient address
         * @param {BusinessAccountRecipientAddressCreationRequest} [businessAccountRecipientAddressCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountRecipientAddress: async (businessAccountRecipientAddressCreationRequest?: BusinessAccountRecipientAddressCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/wallets/addresses/recipient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessAccountRecipientAddressCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a deposit address
         * @param {BusinessAccountGenerateAddressRequest} [businessAccountGenerateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBusinessAccountDepositAddress: async (businessAccountGenerateAddressRequest?: BusinessAccountGenerateAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/wallets/addresses/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessAccountGenerateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountDepositAddresses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/wallets/addresses/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response. 
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountRecipientAddresses: async (from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/wallets/addresses/recipient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. 
         * @summary Create a recipient address
         * @param {BusinessAccountRecipientAddressCreationRequest} [businessAccountRecipientAddressCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest?: BusinessAccountRecipientAddressCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountRecipientAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a deposit address
         * @param {BusinessAccountGenerateAddressRequest} [businessAccountGenerateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest?: BusinessAccountGenerateAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateBusinessAccountDepositAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountDepositAddresses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountDepositAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountDepositAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response. 
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountRecipientAddresses(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountRecipientAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. 
         * @summary Create a recipient address
         * @param {BusinessAccountRecipientAddressCreationRequest} [businessAccountRecipientAddressCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest?: BusinessAccountRecipientAddressCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountRecipientAddressResponse> {
            return localVarFp.createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a deposit address
         * @param {BusinessAccountGenerateAddressRequest} [businessAccountGenerateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest?: BusinessAccountGenerateAddressRequest, options?: any): AxiosPromise<GenerateBusinessAccountDepositAddressResponse> {
            return localVarFp.generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountDepositAddresses(options?: any): AxiosPromise<GetBusinessAccountDepositAddressesResponse> {
            return localVarFp.getBusinessAccountDepositAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response. 
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountRecipientAddresses(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetBusinessAccountRecipientAddressesResponse> {
            return localVarFp.getBusinessAccountRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. 
     * @summary Create a recipient address
     * @param {BusinessAccountRecipientAddressCreationRequest} [businessAccountRecipientAddressCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest?: BusinessAccountRecipientAddressCreationRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).createBusinessAccountRecipientAddress(businessAccountRecipientAddressCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
     * @summary Create a deposit address
     * @param {BusinessAccountGenerateAddressRequest} [businessAccountGenerateAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest?: BusinessAccountGenerateAddressRequest, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).generateBusinessAccountDepositAddress(businessAccountGenerateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all deposit addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getBusinessAccountDepositAddresses(options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getBusinessAccountDepositAddresses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response. 
     * @summary List all recipient addresses
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getBusinessAccountRecipientAddresses(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return AddressesApiFp(this.configuration).getBusinessAccountRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountBalances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountBalances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountBalances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalances(options?: any): AxiosPromise<GetBalancesResponse> {
            return localVarFp.getBalances(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountBalances(options?: any): AxiosPromise<GetBusinessAccountBalancesResponse> {
            return localVarFp.getBusinessAccountBalances(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
     * @summary List all balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public getBalances(options?: AxiosRequestConfig) {
        return BalancesApiFp(this.configuration).getBalances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the balance of funds that are available for use.
     * @summary List all balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public getBusinessAccountBalances(options?: AxiosRequestConfig) {
        return BalancesApiFp(this.configuration).getBusinessAccountBalances(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a card
         * @param {CardCreationRequest} [cardCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard: async (cardCreationRequest?: CardCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCard', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all cards
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards: async (pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CardUpdate} [cardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCard: async (id: string, cardUpdate?: CardUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCard', 'id', id)
            const localVarPath = `/v1/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a card
         * @param {CardCreationRequest} [cardCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCard(cardCreationRequest?: CardCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCard(cardCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCard(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all cards
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCards(pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCards(pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CardUpdate} [cardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCard(id: string, cardUpdate?: CardUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCard(id, cardUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a card
         * @param {CardCreationRequest} [cardCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCard(cardCreationRequest?: CardCreationRequest, options?: any): AxiosPromise<CreateCardResponse> {
            return localVarFp.createCard(cardCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard(id: string, options?: any): AxiosPromise<GetCardResponse> {
            return localVarFp.getCard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all cards
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetCardsResponse> {
            return localVarFp.getCards(pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a card
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CardUpdate} [cardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCard(id: string, cardUpdate?: CardUpdate, options?: any): AxiosPromise<UpdateCardResponse> {
            return localVarFp.updateCard(id, cardUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @summary Create a card
     * @param {CardCreationRequest} [cardCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public createCard(cardCreationRequest?: CardCreationRequest, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).createCard(cardCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a card
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCard(id: string, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all cards
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCards(pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCards(pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a card
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CardUpdate} [cardUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public updateCard(id: string, cardUpdate?: CardUpdate, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).updateCard(id, cardUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of channels with details (e.g. `cardDescriptor`, `achDescriptor`, etc.).
         * @summary List all channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of channels with details (e.g. `cardDescriptor`, `achDescriptor`, etc.).
         * @summary List all channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChannels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChannels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsApiFp(configuration)
    return {
        /**
         * Retrieve a list of channels with details (e.g. `cardDescriptor`, `achDescriptor`, etc.).
         * @summary List all channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannels(options?: any): AxiosPromise<ListChannelsResponse> {
            return localVarFp.listChannels(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * Retrieve a list of channels with details (e.g. `cardDescriptor`, `achDescriptor`, etc.).
     * @summary List all channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public listChannels(options?: AxiosRequestConfig) {
        return ChannelsApiFp(this.configuration).listChannels(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChargebacksApi - axios parameter creator
 * @export
 */
export const ChargebacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * In the sandbox environment, initiate a mock chargeback of a specified payment.  The entire payment will be charged back for its full value.  The payment must be in the `paid` state (otherwise the endpoint will return a `404`), and each payment can only be charged back once (otherwise the endpoint will return a `409`).  This endpoint is only available in the sandbox environment.
         * @summary Create a mock chargeback
         * @param {MockChargebackCreationRequest} [mockChargebackCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMockChargeback: async (mockChargebackCreationRequest?: MockChargebackCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mocks/cards/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockChargebackCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a chargeback
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargeback: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChargeback', 'id', id)
            const localVarPath = `/v1/chargebacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of chargebacks. Results will be sorted by create date descending: more recent chargebacks will be at the beginning of the list. 
         * @summary List all chargebacks
         * @param {string} [paymentId] The payment ID associated with the chargeback.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks: async (paymentId?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paymentId !== undefined) {
                localVarQueryParameter['paymentId'] = paymentId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargebacksApi - functional programming interface
 * @export
 */
export const ChargebacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChargebacksApiAxiosParamCreator(configuration)
    return {
        /**
         * In the sandbox environment, initiate a mock chargeback of a specified payment.  The entire payment will be charged back for its full value.  The payment must be in the `paid` state (otherwise the endpoint will return a `404`), and each payment can only be charged back once (otherwise the endpoint will return a `409`).  This endpoint is only available in the sandbox environment.
         * @summary Create a mock chargeback
         * @param {MockChargebackCreationRequest} [mockChargebackCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMockChargeback(mockChargebackCreationRequest?: MockChargebackCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMockChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMockChargeback(mockChargebackCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a chargeback
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargeback(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargeback(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of chargebacks. Results will be sorted by create date descending: more recent chargebacks will be at the beginning of the list. 
         * @summary List all chargebacks
         * @param {string} [paymentId] The payment ID associated with the chargeback.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargebacks(paymentId?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargebacksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargebacks(paymentId, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChargebacksApi - factory interface
 * @export
 */
export const ChargebacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChargebacksApiFp(configuration)
    return {
        /**
         * In the sandbox environment, initiate a mock chargeback of a specified payment.  The entire payment will be charged back for its full value.  The payment must be in the `paid` state (otherwise the endpoint will return a `404`), and each payment can only be charged back once (otherwise the endpoint will return a `409`).  This endpoint is only available in the sandbox environment.
         * @summary Create a mock chargeback
         * @param {MockChargebackCreationRequest} [mockChargebackCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMockChargeback(mockChargebackCreationRequest?: MockChargebackCreationRequest, options?: any): AxiosPromise<CreateMockChargebackResponse> {
            return localVarFp.createMockChargeback(mockChargebackCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a chargeback
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargeback(id: string, options?: any): AxiosPromise<GetChargebackResponse> {
            return localVarFp.getChargeback(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of chargebacks. Results will be sorted by create date descending: more recent chargebacks will be at the beginning of the list. 
         * @summary List all chargebacks
         * @param {string} [paymentId] The payment ID associated with the chargeback.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks(paymentId?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetChargebacksResponse> {
            return localVarFp.getChargebacks(paymentId, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChargebacksApi - object-oriented interface
 * @export
 * @class ChargebacksApi
 * @extends {BaseAPI}
 */
export class ChargebacksApi extends BaseAPI {
    /**
     * In the sandbox environment, initiate a mock chargeback of a specified payment.  The entire payment will be charged back for its full value.  The payment must be in the `paid` state (otherwise the endpoint will return a `404`), and each payment can only be charged back once (otherwise the endpoint will return a `409`).  This endpoint is only available in the sandbox environment.
     * @summary Create a mock chargeback
     * @param {MockChargebackCreationRequest} [mockChargebackCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public createMockChargeback(mockChargebackCreationRequest?: MockChargebackCreationRequest, options?: AxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).createMockChargeback(mockChargebackCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a chargeback
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargeback(id: string, options?: AxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargeback(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of chargebacks. Results will be sorted by create date descending: more recent chargebacks will be at the beginning of the list. 
     * @summary List all chargebacks
     * @param {string} [paymentId] The payment ID associated with the chargeback.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargebacks(paymentId?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargebacks(paymentId, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DepositsApi - axios parameter creator
 * @export
 */
export const DepositsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * In the sandbox environment, initiate a mock SEN transfer that mimics the behavior of funds sent through the Silvergate SEN account linked to master wallet.
         * @summary Create a mock Silvergate SEN payment
         * @param {MockSenPaymentRequest} [mockSenPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSenPayment: async (mockSenPaymentRequest?: MockSenPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mocks/payments/sen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockSenPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for deposits sent to your business account. If the date parameters are omitted, returns the most recent deposits. This endpoint returns up to 50 deposits in descending chronological order or pageSize, if provided.
         * @summary List all deposits
         * @param {'wire'} [type] Unique identifier for the deposit type. Filters results to fetch deposits made by this specific type.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusinessAccountDeposits: async (type?: 'wire', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepositsApi - functional programming interface
 * @export
 */
export const DepositsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepositsApiAxiosParamCreator(configuration)
    return {
        /**
         * In the sandbox environment, initiate a mock SEN transfer that mimics the behavior of funds sent through the Silvergate SEN account linked to master wallet.
         * @summary Create a mock Silvergate SEN payment
         * @param {MockSenPaymentRequest} [mockSenPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSenPayment(mockSenPaymentRequest?: MockSenPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSenPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSenPayment(mockSenPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for deposits sent to your business account. If the date parameters are omitted, returns the most recent deposits. This endpoint returns up to 50 deposits in descending chronological order or pageSize, if provided.
         * @summary List all deposits
         * @param {'wire'} [type] Unique identifier for the deposit type. Filters results to fetch deposits made by this specific type.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBusinessAccountDeposits(type?: 'wire', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchBusinessAccountDepositsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBusinessAccountDeposits(type, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DepositsApi - factory interface
 * @export
 */
export const DepositsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepositsApiFp(configuration)
    return {
        /**
         * In the sandbox environment, initiate a mock SEN transfer that mimics the behavior of funds sent through the Silvergate SEN account linked to master wallet.
         * @summary Create a mock Silvergate SEN payment
         * @param {MockSenPaymentRequest} [mockSenPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSenPayment(mockSenPaymentRequest?: MockSenPaymentRequest, options?: any): AxiosPromise<CreateSenPaymentResponse> {
            return localVarFp.createSenPayment(mockSenPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for deposits sent to your business account. If the date parameters are omitted, returns the most recent deposits. This endpoint returns up to 50 deposits in descending chronological order or pageSize, if provided.
         * @summary List all deposits
         * @param {'wire'} [type] Unique identifier for the deposit type. Filters results to fetch deposits made by this specific type.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusinessAccountDeposits(type?: 'wire', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<SearchBusinessAccountDepositsResponse> {
            return localVarFp.searchBusinessAccountDeposits(type, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepositsApi - object-oriented interface
 * @export
 * @class DepositsApi
 * @extends {BaseAPI}
 */
export class DepositsApi extends BaseAPI {
    /**
     * In the sandbox environment, initiate a mock SEN transfer that mimics the behavior of funds sent through the Silvergate SEN account linked to master wallet.
     * @summary Create a mock Silvergate SEN payment
     * @param {MockSenPaymentRequest} [mockSenPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    public createSenPayment(mockSenPaymentRequest?: MockSenPaymentRequest, options?: AxiosRequestConfig) {
        return DepositsApiFp(this.configuration).createSenPayment(mockSenPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for deposits sent to your business account. If the date parameters are omitted, returns the most recent deposits. This endpoint returns up to 50 deposits in descending chronological order or pageSize, if provided.
     * @summary List all deposits
     * @param {'wire'} [type] Unique identifier for the deposit type. Filters results to fetch deposits made by this specific type.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepositsApi
     */
    public searchBusinessAccountDeposits(type?: 'wire', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return DepositsApiFp(this.configuration).searchBusinessAccountDeposits(type, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EncryptionApi - axios parameter creator
 * @export
 */
export const EncryptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves an RSA public key to be used in encrypting data sent to the API. Your public keys change infrequently, so we encourage you to cache this response value locally for a duration of 24 hours or more.
         * @summary Get public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/encryption/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EncryptionApi - functional programming interface
 * @export
 */
export const EncryptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EncryptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves an RSA public key to be used in encrypting data sent to the API. Your public keys change infrequently, so we encourage you to cache this response value locally for a duration of 24 hours or more.
         * @summary Get public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EncryptionApi - factory interface
 * @export
 */
export const EncryptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EncryptionApiFp(configuration)
    return {
        /**
         * Retrieves an RSA public key to be used in encrypting data sent to the API. Your public keys change infrequently, so we encourage you to cache this response value locally for a duration of 24 hours or more.
         * @summary Get public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any): AxiosPromise<GetPublicKeyResponse> {
            return localVarFp.getPublicKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EncryptionApi - object-oriented interface
 * @export
 * @class EncryptionApi
 * @extends {BaseAPI}
 */
export class EncryptionApi extends BaseAPI {
    /**
     * Retrieves an RSA public key to be used in encrypting data sent to the API. Your public keys change infrequently, so we encourage you to cache this response value locally for a duration of 24 hours or more.
     * @summary Get public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EncryptionApi
     */
    public getPublicKey(options?: AxiosRequestConfig) {
        return EncryptionApiFp(this.configuration).getPublicKey(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootPing: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootPing(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootPing(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootPing(options?: any): AxiosPromise<Ping> {
            return localVarFp.rootPing(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public rootPing(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).rootPing(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagementApi - axios parameter creator
 * @export
 */
export const ManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves general configuration information.
         * @summary Get configuration info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagementApi - functional programming interface
 * @export
 */
export const ManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves general configuration information.
         * @summary Get configuration info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagementApi - factory interface
 * @export
 */
export const ManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagementApiFp(configuration)
    return {
        /**
         * Retrieves general configuration information.
         * @summary Get configuration info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<GetConfigResponse> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagementApi - object-oriented interface
 * @export
 * @class ManagementApi
 * @extends {BaseAPI}
 */
export class ManagementApi extends BaseAPI {
    /**
     * Retrieves general configuration information.
     * @summary Get configuration info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagementApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return ManagementApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted. 
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: async (id: string, cancelCreationRequest?: CancelCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelPayment', 'id', id)
            const localVarPath = `/v1/payments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted. 
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment: async (id: string, captureCreationRequest?: CaptureCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturePayment', 'id', id)
            const localVarPath = `/v1/payments/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(captureCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (paymentCreationRequest?: PaymentCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In the sandbox environment, initiate a mock SEPA payment that mimics the behavior of funds sent through the bank (SEPA) account linked to master wallet.
         * @summary Create a mock SEPA payment
         * @param {MockSepaPaymentRequest} [mockSepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSepaPayment: async (mockSepaPaymentRequest?: MockSepaPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mocks/payments/sepa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockSepaPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWirePayment: async (mockWirePaymentRequest?: MockWirePaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mocks/payments/wire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mockWirePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayment', 'id', id)
            const localVarPath = `/v1/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {Array<'card' | 'wire' | 'ach' | 'sepa'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: async (source?: string, settlementId?: string, type?: Array<'card' | 'wire' | 'ach' | 'sepa'>, status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (settlementId !== undefined) {
                localVarQueryParameter['settlementId'] = settlementId;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted. 
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: async (id: string, refundCreationRequest?: RefundCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refundPayment', 'id', id)
            const localVarPath = `/v1/payments/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted. 
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayment(id: string, cancelCreationRequest?: CancelCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayment(id, cancelCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted. 
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturePayment(id: string, captureCreationRequest?: CaptureCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturePayment(id, captureCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(paymentCreationRequest?: PaymentCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(paymentCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In the sandbox environment, initiate a mock SEPA payment that mimics the behavior of funds sent through the bank (SEPA) account linked to master wallet.
         * @summary Create a mock SEPA payment
         * @param {MockSepaPaymentRequest} [mockSepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSepaPayment(mockSepaPaymentRequest?: MockSepaPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSepaPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSepaPayment(mockSepaPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWirePayment(mockWirePaymentRequest?: MockWirePaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWirePaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWirePayment(mockWirePaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {Array<'card' | 'wire' | 'ach' | 'sepa'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayments(source?: string, settlementId?: string, type?: Array<'card' | 'wire' | 'ach' | 'sepa'>, status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayments(source, settlementId, type, status, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted. 
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPayment(id: string, refundCreationRequest?: RefundCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPayment(id, refundCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted. 
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(id: string, cancelCreationRequest?: CancelCreationRequest, options?: any): AxiosPromise<CancelPaymentResponse> {
            return localVarFp.cancelPayment(id, cancelCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted. 
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment(id: string, captureCreationRequest?: CaptureCreationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.capturePayment(id, captureCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(paymentCreationRequest?: PaymentCreationRequest, options?: any): AxiosPromise<CreatePaymentResponse> {
            return localVarFp.createPayment(paymentCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * In the sandbox environment, initiate a mock SEPA payment that mimics the behavior of funds sent through the bank (SEPA) account linked to master wallet.
         * @summary Create a mock SEPA payment
         * @param {MockSepaPaymentRequest} [mockSepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSepaPayment(mockSepaPaymentRequest?: MockSepaPaymentRequest, options?: any): AxiosPromise<CreateSepaPaymentResponse> {
            return localVarFp.createSepaPayment(mockSepaPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWirePayment(mockWirePaymentRequest?: MockWirePaymentRequest, options?: any): AxiosPromise<CreateWirePaymentResponse> {
            return localVarFp.createWirePayment(mockWirePaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(id: string, options?: any): AxiosPromise<GetPaymentResponse> {
            return localVarFp.getPayment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {Array<'card' | 'wire' | 'ach' | 'sepa'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(source?: string, settlementId?: string, type?: Array<'card' | 'wire' | 'ach' | 'sepa'>, status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetPaymentsResponse> {
            return localVarFp.getPayments(source, settlementId, type, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted. 
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(id: string, refundCreationRequest?: RefundCreationRequest, options?: any): AxiosPromise<RefundPaymentResponse> {
            return localVarFp.refundPayment(id, refundCreationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted. 
     * @summary Cancel a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CancelCreationRequest} [cancelCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancelPayment(id: string, cancelCreationRequest?: CancelCreationRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).cancelPayment(id, cancelCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted. 
     * @summary Capture a payment (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CaptureCreationRequest} [captureCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public capturePayment(id: string, captureCreationRequest?: CaptureCreationRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).capturePayment(id, captureCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a payment
     * @param {PaymentCreationRequest} [paymentCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(paymentCreationRequest?: PaymentCreationRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(paymentCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In the sandbox environment, initiate a mock SEPA payment that mimics the behavior of funds sent through the bank (SEPA) account linked to master wallet.
     * @summary Create a mock SEPA payment
     * @param {MockSepaPaymentRequest} [mockSepaPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createSepaPayment(mockSepaPaymentRequest?: MockSepaPaymentRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createSepaPayment(mockSepaPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
     * @summary Create a mock Wire payment
     * @param {MockWirePaymentRequest} [mockWirePaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createWirePayment(mockWirePaymentRequest?: MockWirePaymentRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createWirePayment(mockWirePaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(id: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payments
     * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
     * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
     * @param {Array<'card' | 'wire' | 'ach' | 'sepa'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
     * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayments(source?: string, settlementId?: string, type?: Array<'card' | 'wire' | 'ach' | 'sepa'>, status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayments(source, settlementId, type, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted. 
     * @summary Refund a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {RefundCreationRequest} [refundCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refundPayment(id: string, refundCreationRequest?: RefundCreationRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).refundPayment(id, refundCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutsApi - axios parameter creator
 * @export
 */
export const PayoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a payout
         * @param {BusinessAccountPayoutCreationRequest} [businessAccountPayoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountPayout: async (businessAccountPayoutCreationRequest?: BusinessAccountPayoutCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessAccountPayoutCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a payout
         * @param {PayoutCreationRequest} [payoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout: async (payoutCreationRequest?: PayoutCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountPayout: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountPayout', 'id', id)
            const localVarPath = `/v1/businessAccount/payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountPayouts: async (destination?: string, type?: 'wire', status?: Array<PayoutStatus>, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayout', 'id', id)
            const localVarPath = `/v1/payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [source] Universally unique identifier (UUID v4) for the source wallet. Filters the results to fetch all payouts made from a source wallet. If not provided, payouts from all wallets will be returned.
         * @param {Array<PayoutDestinationType>} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts: async (source?: string, type?: Array<PayoutDestinationType>, status?: Array<PayoutStatus>, destination?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutsApi - functional programming interface
 * @export
 */
export const PayoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a payout
         * @param {BusinessAccountPayoutCreationRequest} [businessAccountPayoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountPayout(businessAccountPayoutCreationRequest?: BusinessAccountPayoutCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountPayout(businessAccountPayoutCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a payout
         * @param {PayoutCreationRequest} [payoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayout(payoutCreationRequest?: PayoutCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayout(payoutCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountPayout(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountPayout(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountPayouts(destination?: string, type?: 'wire', status?: Array<PayoutStatus>, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayout(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayout(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [source] Universally unique identifier (UUID v4) for the source wallet. Filters the results to fetch all payouts made from a source wallet. If not provided, payouts from all wallets will be returned.
         * @param {Array<PayoutDestinationType>} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayouts(source?: string, type?: Array<PayoutDestinationType>, status?: Array<PayoutStatus>, destination?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayouts(source, type, status, destination, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutsApi - factory interface
 * @export
 */
export const PayoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a payout
         * @param {BusinessAccountPayoutCreationRequest} [businessAccountPayoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountPayout(businessAccountPayoutCreationRequest?: BusinessAccountPayoutCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountPayoutResponse> {
            return localVarFp.createBusinessAccountPayout(businessAccountPayoutCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a payout
         * @param {PayoutCreationRequest} [payoutCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout(payoutCreationRequest?: PayoutCreationRequest, options?: any): AxiosPromise<CreatePayoutResponse> {
            return localVarFp.createPayout(payoutCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountPayout(id: string, options?: any): AxiosPromise<GetBusinessAccountPayoutResponse> {
            return localVarFp.getBusinessAccountPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {'wire'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountPayouts(destination?: string, type?: 'wire', status?: Array<PayoutStatus>, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetBusinessAccountPayoutsResponse> {
            return localVarFp.getBusinessAccountPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a payout
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout(id: string, options?: any): AxiosPromise<GetPayoutResponse> {
            return localVarFp.getPayout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payouts
         * @param {string} [source] Universally unique identifier (UUID v4) for the source wallet. Filters the results to fetch all payouts made from a source wallet. If not provided, payouts from all wallets will be returned.
         * @param {Array<PayoutDestinationType>} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
         * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts(source?: string, type?: Array<PayoutDestinationType>, status?: Array<PayoutStatus>, destination?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetPayoutsResponse> {
            return localVarFp.getPayouts(source, type, status, destination, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutsApi - object-oriented interface
 * @export
 * @class PayoutsApi
 * @extends {BaseAPI}
 */
export class PayoutsApi extends BaseAPI {
    /**
     * 
     * @summary Create a payout
     * @param {BusinessAccountPayoutCreationRequest} [businessAccountPayoutCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public createBusinessAccountPayout(businessAccountPayoutCreationRequest?: BusinessAccountPayoutCreationRequest, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).createBusinessAccountPayout(businessAccountPayoutCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a payout
     * @param {PayoutCreationRequest} [payoutCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public createPayout(payoutCreationRequest?: PayoutCreationRequest, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).createPayout(payoutCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a payout
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public getBusinessAccountPayout(id: string, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).getBusinessAccountPayout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payouts
     * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
     * @param {'wire'} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
     * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public getBusinessAccountPayouts(destination?: string, type?: 'wire', status?: Array<PayoutStatus>, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).getBusinessAccountPayouts(destination, type, status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a payout
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public getPayout(id: string, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).getPayout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payouts
     * @param {string} [source] Universally unique identifier (UUID v4) for the source wallet. Filters the results to fetch all payouts made from a source wallet. If not provided, payouts from all wallets will be returned.
     * @param {Array<PayoutDestinationType>} [type] Destination bank account type. Filters the results to fetch all payouts made to a specified destination bank account type. This query parameter can be passed multiple times to fetch results matching multiple destination bank account types.
     * @param {Array<PayoutStatus>} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [destination] Universally unique identifier (UUID v4) for the destination bank account. Filters the results to fetch all payouts made to a destination bank account.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public getPayouts(source?: string, type?: Array<PayoutDestinationType>, status?: Array<PayoutStatus>, destination?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).getPayouts(source, type, status, destination, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReturnsApi - axios parameter creator
 * @export
 */
export const ReturnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of Wire and ACH payout returns. Results will be sorted by create date descending; more recent returns will be at the beginning of the list.
         * @summary List all payout returns
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns: async (from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReturnsApi - functional programming interface
 * @export
 */
export const ReturnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReturnsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of Wire and ACH payout returns. Results will be sorted by create date descending; more recent returns will be at the beginning of the list.
         * @summary List all payout returns
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturns(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReturnsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturns(from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReturnsApi - factory interface
 * @export
 */
export const ReturnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReturnsApiFp(configuration)
    return {
        /**
         * Retrieve a list of Wire and ACH payout returns. Results will be sorted by create date descending; more recent returns will be at the beginning of the list.
         * @summary List all payout returns
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturns(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetReturnsResponse> {
            return localVarFp.getReturns(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReturnsApi - object-oriented interface
 * @export
 * @class ReturnsApi
 * @extends {BaseAPI}
 */
export class ReturnsApi extends BaseAPI {
    /**
     * Retrieve a list of Wire and ACH payout returns. Results will be sorted by create date descending; more recent returns will be at the beginning of the list.
     * @summary List all payout returns
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReturnsApi
     */
    public getReturns(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return ReturnsApiFp(this.configuration).getReturns(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReversalsApi - axios parameter creator
 * @export
 */
export const ReversalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of ACH payment reversals. Results will be sorted by create date descending; more recent reversals will be at the beginning of the list
         * @summary List all ACH payment reversals.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReversals: async (status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reversals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReversalsApi - functional programming interface
 * @export
 */
export const ReversalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReversalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of ACH payment reversals. Results will be sorted by create date descending; more recent reversals will be at the beginning of the list
         * @summary List all ACH payment reversals.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReversals(status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReversalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReversals(status, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReversalsApi - factory interface
 * @export
 */
export const ReversalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReversalsApiFp(configuration)
    return {
        /**
         * Retrieve a list of ACH payment reversals. Results will be sorted by create date descending; more recent reversals will be at the beginning of the list
         * @summary List all ACH payment reversals.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReversals(status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetReversalsResponse> {
            return localVarFp.getReversals(status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReversalsApi - object-oriented interface
 * @export
 * @class ReversalsApi
 * @extends {BaseAPI}
 */
export class ReversalsApi extends BaseAPI {
    /**
     * Retrieve a list of ACH payment reversals. Results will be sorted by create date descending; more recent reversals will be at the beginning of the list
     * @summary List all ACH payment reversals.
     * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReversalsApi
     */
    public getReversals(status?: 'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required', from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return ReversalsApiFp(this.configuration).getReversals(status, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SENApi - axios parameter creator
 * @export
 */
export const SENApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Silvergate SEN bank account (BETA)
         * @param {SenFiatAccountCreationRequest} [senFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountSenBankAccount: async (senFiatAccountCreationRequest?: SenFiatAccountCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/sen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(senFiatAccountCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Silvergate SEN bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountSenBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/sen/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Silvergate SEN bank accounts (BETA).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenBankAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/sen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Silvergate SEN transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get Silvergate SEN instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenInstructionsBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountSenInstructionsBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/sen/{id}/instructions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SENApi - functional programming interface
 * @export
 */
export const SENApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SENApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Silvergate SEN bank account (BETA)
         * @param {SenFiatAccountCreationRequest} [senFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountSenBankAccount(senFiatAccountCreationRequest?: SenFiatAccountCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountSenBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountSenBankAccount(senFiatAccountCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Silvergate SEN bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSenBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSenBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSenBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Silvergate SEN bank accounts (BETA).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSenBankAccounts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSenBankAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSenBankAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Silvergate SEN transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get Silvergate SEN instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSenInstructionsBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSenInstructionsBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSenInstructionsBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SENApi - factory interface
 * @export
 */
export const SENApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SENApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Silvergate SEN bank account (BETA)
         * @param {SenFiatAccountCreationRequest} [senFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountSenBankAccount(senFiatAccountCreationRequest?: SenFiatAccountCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountSenBankAccountResponse> {
            return localVarFp.createBusinessAccountSenBankAccount(senFiatAccountCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Silvergate SEN bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountSenBankAccountResponse> {
            return localVarFp.getBusinessAccountSenBankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Silvergate SEN bank accounts (BETA).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenBankAccounts(options?: any): AxiosPromise<GetBusinessAccountSenBankAccounts200Response> {
            return localVarFp.getBusinessAccountSenBankAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Silvergate SEN transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get Silvergate SEN instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSenInstructionsBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountSenInstructionsBankAccountResponse> {
            return localVarFp.getBusinessAccountSenInstructionsBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SENApi - object-oriented interface
 * @export
 * @class SENApi
 * @extends {BaseAPI}
 */
export class SENApi extends BaseAPI {
    /**
     * 
     * @summary Create a Silvergate SEN bank account (BETA)
     * @param {SenFiatAccountCreationRequest} [senFiatAccountCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SENApi
     */
    public createBusinessAccountSenBankAccount(senFiatAccountCreationRequest?: SenFiatAccountCreationRequest, options?: AxiosRequestConfig) {
        return SENApiFp(this.configuration).createBusinessAccountSenBankAccount(senFiatAccountCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Silvergate SEN bank account (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SENApi
     */
    public getBusinessAccountSenBankAccount(id: string, options?: AxiosRequestConfig) {
        return SENApiFp(this.configuration).getBusinessAccountSenBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Silvergate SEN bank accounts (BETA).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SENApi
     */
    public getBusinessAccountSenBankAccounts(options?: AxiosRequestConfig) {
        return SENApiFp(this.configuration).getBusinessAccountSenBankAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Silvergate SEN transfer instructions into the Circle bank account given your bank account id (BETA).
     * @summary Get Silvergate SEN instructions (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SENApi
     */
    public getBusinessAccountSenInstructionsBankAccount(id: string, options?: AxiosRequestConfig) {
        return SENApiFp(this.configuration).getBusinessAccountSenInstructionsBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SEPAApi - axios parameter creator
 * @export
 */
export const SEPAApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a SEPA bank account (BETA)
         * @param {SEPACreationRequest} [sEPACreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSEPABankAccount: async (sEPACreationRequest?: SEPACreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/banks/sepa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sEPACreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a SEPA bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSEPABankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSEPABankAccount', 'id', id)
            const localVarPath = `/v1/banks/sepa/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the SEPA transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get SEPA instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSEPAInstructionsBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSEPAInstructionsBankAccount', 'id', id)
            const localVarPath = `/v1/banks/sepa/{id}/instructions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SEPAApi - functional programming interface
 * @export
 */
export const SEPAApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SEPAApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a SEPA bank account (BETA)
         * @param {SEPACreationRequest} [sEPACreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSEPABankAccount(sEPACreationRequest?: SEPACreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSEPABankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSEPABankAccount(sEPACreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a SEPA bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSEPABankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSEPABankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSEPABankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the SEPA transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get SEPA instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSEPAInstructionsBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSEPAInstructionsBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSEPAInstructionsBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SEPAApi - factory interface
 * @export
 */
export const SEPAApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SEPAApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a SEPA bank account (BETA)
         * @param {SEPACreationRequest} [sEPACreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSEPABankAccount(sEPACreationRequest?: SEPACreationRequest, options?: any): AxiosPromise<CreateSEPABankAccountResponse> {
            return localVarFp.createSEPABankAccount(sEPACreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a SEPA bank account (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSEPABankAccount(id: string, options?: any): AxiosPromise<GetSEPABankAccountResponse> {
            return localVarFp.getSEPABankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the SEPA transfer instructions into the Circle bank account given your bank account id (BETA).
         * @summary Get SEPA instructions (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSEPAInstructionsBankAccount(id: string, options?: any): AxiosPromise<GetSEPAInstructionsBankAccountResponse> {
            return localVarFp.getSEPAInstructionsBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SEPAApi - object-oriented interface
 * @export
 * @class SEPAApi
 * @extends {BaseAPI}
 */
export class SEPAApi extends BaseAPI {
    /**
     * 
     * @summary Create a SEPA bank account (BETA)
     * @param {SEPACreationRequest} [sEPACreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAApi
     */
    public createSEPABankAccount(sEPACreationRequest?: SEPACreationRequest, options?: AxiosRequestConfig) {
        return SEPAApiFp(this.configuration).createSEPABankAccount(sEPACreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a SEPA bank account (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAApi
     */
    public getSEPABankAccount(id: string, options?: AxiosRequestConfig) {
        return SEPAApiFp(this.configuration).getSEPABankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the SEPA transfer instructions into the Circle bank account given your bank account id (BETA).
     * @summary Get SEPA instructions (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAApi
     */
    public getSEPAInstructionsBankAccount(id: string, options?: AxiosRequestConfig) {
        return SEPAApiFp(this.configuration).getSEPAInstructionsBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettlementsApi - axios parameter creator
 * @export
 */
export const SettlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a settlement
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettlement: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSettlement', 'id', id)
            const localVarPath = `/v1/settlements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all settlements
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettlements: async (from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettlementsApi - functional programming interface
 * @export
 */
export const SettlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a settlement
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettlement(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettlementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettlement(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all settlements
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettlements(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettlementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettlements(from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettlementsApi - factory interface
 * @export
 */
export const SettlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettlementsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a settlement
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettlement(id: string, options?: any): AxiosPromise<GetSettlementResponse> {
            return localVarFp.getSettlement(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all settlements
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettlements(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetSettlementsResponse> {
            return localVarFp.getSettlements(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettlementsApi - object-oriented interface
 * @export
 * @class SettlementsApi
 * @extends {BaseAPI}
 */
export class SettlementsApi extends BaseAPI {
    /**
     * 
     * @summary Get a settlement
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementsApi
     */
    public getSettlement(id: string, options?: AxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).getSettlement(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all settlements
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettlementsApi
     */
    public getSettlements(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return SettlementsApiFp(this.configuration).getSettlements(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignetApi - axios parameter creator
 * @export
 */
export const SignetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Signet bank account (Production Only)
         * @param {SignetFiatAccountCreationRequest} [signetFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountSignetBankAccount: async (signetFiatAccountCreationRequest?: SignetFiatAccountCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/signet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signetFiatAccountCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Signet bank account (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountSignetBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/signet/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Signet bank accounts (Production Only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetBankAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/signet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Signet transfer instructions into the Circle bank account given your bank account id (only available on Production now).
         * @summary Get Signet instructions (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetInstructionsBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountSignetInstructionsBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/signet/{id}/instructions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignetApi - functional programming interface
 * @export
 */
export const SignetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Signet bank account (Production Only)
         * @param {SignetFiatAccountCreationRequest} [signetFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest?: SignetFiatAccountCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountSignetBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Signet bank account (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSignetBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSignetBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSignetBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Signet bank accounts (Production Only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSignetBankAccounts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSignetBankAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSignetBankAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Signet transfer instructions into the Circle bank account given your bank account id (only available on Production now).
         * @summary Get Signet instructions (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountSignetInstructionsBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountSignetInstructionsBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountSignetInstructionsBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignetApi - factory interface
 * @export
 */
export const SignetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignetApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Signet bank account (Production Only)
         * @param {SignetFiatAccountCreationRequest} [signetFiatAccountCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest?: SignetFiatAccountCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountSignetBankAccountResponse> {
            return localVarFp.createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Signet bank account (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountSignetBankAccountResponse> {
            return localVarFp.getBusinessAccountSignetBankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Signet bank accounts (Production Only).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetBankAccounts(options?: any): AxiosPromise<GetBusinessAccountSignetBankAccountsResponse> {
            return localVarFp.getBusinessAccountSignetBankAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Signet transfer instructions into the Circle bank account given your bank account id (only available on Production now).
         * @summary Get Signet instructions (Production Only)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountSignetInstructionsBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountSignetInstructionsBankAccountResponse> {
            return localVarFp.getBusinessAccountSignetInstructionsBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignetApi - object-oriented interface
 * @export
 * @class SignetApi
 * @extends {BaseAPI}
 */
export class SignetApi extends BaseAPI {
    /**
     * 
     * @summary Create a Signet bank account (Production Only)
     * @param {SignetFiatAccountCreationRequest} [signetFiatAccountCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignetApi
     */
    public createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest?: SignetFiatAccountCreationRequest, options?: AxiosRequestConfig) {
        return SignetApiFp(this.configuration).createBusinessAccountSignetBankAccount(signetFiatAccountCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Signet bank account (Production Only)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignetApi
     */
    public getBusinessAccountSignetBankAccount(id: string, options?: AxiosRequestConfig) {
        return SignetApiFp(this.configuration).getBusinessAccountSignetBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Signet bank accounts (Production Only).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignetApi
     */
    public getBusinessAccountSignetBankAccounts(options?: AxiosRequestConfig) {
        return SignetApiFp(this.configuration).getBusinessAccountSignetBankAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Signet transfer instructions into the Circle bank account given your bank account id (only available on Production now).
     * @summary Get Signet instructions (Production Only)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignetApi
     */
    public getBusinessAccountSignetInstructionsBankAccount(id: string, options?: AxiosRequestConfig) {
        return SignetApiFp(this.configuration).getBusinessAccountSignetInstructionsBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StablecoinsApi - axios parameter creator
 * @export
 */
export const StablecoinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves total circulating supply for supported stablecoins across all chains. This endpoint is rate limited to one call per minute (based on IP).
         * @summary List all stablecoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStablecoins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stablecoins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StablecoinsApi - functional programming interface
 * @export
 */
export const StablecoinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StablecoinsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves total circulating supply for supported stablecoins across all chains. This endpoint is rate limited to one call per minute (based on IP).
         * @summary List all stablecoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStablecoins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStablecoinsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStablecoins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StablecoinsApi - factory interface
 * @export
 */
export const StablecoinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StablecoinsApiFp(configuration)
    return {
        /**
         * Retrieves total circulating supply for supported stablecoins across all chains. This endpoint is rate limited to one call per minute (based on IP).
         * @summary List all stablecoins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStablecoins(options?: any): AxiosPromise<GetStablecoinsResponse> {
            return localVarFp.getStablecoins(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StablecoinsApi - object-oriented interface
 * @export
 * @class StablecoinsApi
 * @extends {BaseAPI}
 */
export class StablecoinsApi extends BaseAPI {
    /**
     * Retrieves total circulating supply for supported stablecoins across all chains. This endpoint is rate limited to one call per minute (based on IP).
     * @summary List all stablecoins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StablecoinsApi
     */
    public getStablecoins(options?: AxiosRequestConfig) {
        return StablecoinsApiFp(this.configuration).getStablecoins(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of existing notification subscriptions with details.
         * @summary List all notification subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe to receiving notifications at a given endpoint. The endpoint should be able to handle AWS SNS subscription requests. For more details see https://docs.aws.amazon.com/mobile/sdkforxamarin/developerguide/sns-send-http.html. Note, the sandbox environment allows a maximum of 3 active subscriptions; otherwise, this is limited to 1 active subscription and subsequent create requests will be rejected with a Limit Exceeded error. 
         * @summary Create a notification subscription
         * @param {SubscriptionRequest} [subscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe: async (subscriptionRequest?: SubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To remove a subscription, all its subscription requests\' statuses must be either \'confirmed\', \'deleted\' or a combination of those. A subscription with at least one \'pending\' subscription request cannot be removed.
         * @summary Remove a notification subscription
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribe', 'id', id)
            const localVarPath = `/v1/notifications/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of existing notification subscriptions with details.
         * @summary List all notification subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListSubscriptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscribe to receiving notifications at a given endpoint. The endpoint should be able to handle AWS SNS subscription requests. For more details see https://docs.aws.amazon.com/mobile/sdkforxamarin/developerguide/sns-send-http.html. Note, the sandbox environment allows a maximum of 3 active subscriptions; otherwise, this is limited to 1 active subscription and subsequent create requests will be rejected with a Limit Exceeded error. 
         * @summary Create a notification subscription
         * @param {SubscriptionRequest} [subscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribe(subscriptionRequest?: SubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscribeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribe(subscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To remove a subscription, all its subscription requests\' statuses must be either \'confirmed\', \'deleted\' or a combination of those. A subscription with at least one \'pending\' subscription request cannot be removed.
         * @summary Remove a notification subscription
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUnsubscribeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Retrieve a list of existing notification subscriptions with details.
         * @summary List all notification subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(options?: any): AxiosPromise<GetListSubscriptionsResponse> {
            return localVarFp.listSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe to receiving notifications at a given endpoint. The endpoint should be able to handle AWS SNS subscription requests. For more details see https://docs.aws.amazon.com/mobile/sdkforxamarin/developerguide/sns-send-http.html. Note, the sandbox environment allows a maximum of 3 active subscriptions; otherwise, this is limited to 1 active subscription and subsequent create requests will be rejected with a Limit Exceeded error. 
         * @summary Create a notification subscription
         * @param {SubscriptionRequest} [subscriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe(subscriptionRequest?: SubscriptionRequest, options?: any): AxiosPromise<SubscribeResponse> {
            return localVarFp.subscribe(subscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To remove a subscription, all its subscription requests\' statuses must be either \'confirmed\', \'deleted\' or a combination of those. A subscription with at least one \'pending\' subscription request cannot be removed.
         * @summary Remove a notification subscription
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe(id: string, options?: any): AxiosPromise<DeleteUnsubscribeResponse> {
            return localVarFp.unsubscribe(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Retrieve a list of existing notification subscriptions with details.
     * @summary List all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptions(options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe to receiving notifications at a given endpoint. The endpoint should be able to handle AWS SNS subscription requests. For more details see https://docs.aws.amazon.com/mobile/sdkforxamarin/developerguide/sns-send-http.html. Note, the sandbox environment allows a maximum of 3 active subscriptions; otherwise, this is limited to 1 active subscription and subsequent create requests will be rejected with a Limit Exceeded error. 
     * @summary Create a notification subscription
     * @param {SubscriptionRequest} [subscriptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscribe(subscriptionRequest?: SubscriptionRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscribe(subscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To remove a subscription, all its subscription requests\' statuses must be either \'confirmed\', \'deleted\' or a combination of those. A subscription with at least one \'pending\' subscription request cannot be removed.
     * @summary Remove a notification subscription
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public unsubscribe(id: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).unsubscribe(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessAccountTransferCreationRequest} [businessAccountTransferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountTransfer: async (businessAccountTransferCreationRequest?: BusinessAccountTransferCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessAccountTransferCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (transferCreationRequest?: TransferCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountTransfer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountTransfer', 'id', id)
            const localVarPath = `/v1/businessAccount/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (id: string, returnIdentities?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransfer', 'id', id)
            const localVarPath = `/v1/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (returnIdentities !== undefined) {
                localVarQueryParameter['returnIdentities'] = returnIdentities;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusinessAccountTransfers: async (from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransfers: async (walletId?: string, sourceWalletId?: string, destinationWalletId?: string, returnIdentities?: boolean, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (walletId !== undefined) {
                localVarQueryParameter['walletId'] = walletId;
            }

            if (sourceWalletId !== undefined) {
                localVarQueryParameter['sourceWalletId'] = sourceWalletId;
            }

            if (destinationWalletId !== undefined) {
                localVarQueryParameter['destinationWalletId'] = destinationWalletId;
            }

            if (returnIdentities !== undefined) {
                localVarQueryParameter['returnIdentities'] = returnIdentities;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessAccountTransferCreationRequest} [businessAccountTransferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountTransfer(businessAccountTransferCreationRequest?: BusinessAccountTransferCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountTransfer(businessAccountTransferCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(transferCreationRequest?: TransferCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(transferCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountTransfer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountTransfer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(id: string, returnIdentities?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(id, returnIdentities, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBusinessAccountTransfers(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchBusinessAccountTransfersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBusinessAccountTransfers(from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTransfers(walletId?: string, sourceWalletId?: string, destinationWalletId?: string, returnIdentities?: boolean, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchTransfersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessAccountTransferCreationRequest} [businessAccountTransferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountTransfer(businessAccountTransferCreationRequest?: BusinessAccountTransferCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountTransferResponse> {
            return localVarFp.createBusinessAccountTransfer(businessAccountTransferCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferCreationRequest?: TransferCreationRequest, options?: any): AxiosPromise<CreateTransferResponse> {
            return localVarFp.createTransfer(transferCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountTransfer(id: string, options?: any): AxiosPromise<GetBusinessAccountTransferResponse> {
            return localVarFp.getBusinessAccountTransfer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(id: string, returnIdentities?: boolean, options?: any): AxiosPromise<GetTransferResponse> {
            return localVarFp.getTransfer(id, returnIdentities, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusinessAccountTransfers(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<SearchBusinessAccountTransfersResponse> {
            return localVarFp.searchBusinessAccountTransfers(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransfers(walletId?: string, sourceWalletId?: string, destinationWalletId?: string, returnIdentities?: boolean, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<SearchTransfersResponse> {
            return localVarFp.searchTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * A transfer can be made from an existing business account to a blockchain location.
     * @summary Create a transfer
     * @param {BusinessAccountTransferCreationRequest} [businessAccountTransferCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createBusinessAccountTransfer(businessAccountTransferCreationRequest?: BusinessAccountTransferCreationRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createBusinessAccountTransfer(businessAccountTransferCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
     * @summary Create a transfer
     * @param {TransferCreationRequest} [transferCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public createTransfer(transferCreationRequest?: TransferCreationRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).createTransfer(transferCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a transfer
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getBusinessAccountTransfer(id: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getBusinessAccountTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a transfer
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getTransfer(id: string, returnIdentities?: boolean, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getTransfer(id, returnIdentities, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
     * @summary List all transfers
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public searchBusinessAccountTransfers(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).searchBusinessAccountTransfers(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
     * @summary List all transfers
     * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
     * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
     * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
     * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public searchTransfers(walletId?: string, sourceWalletId?: string, destinationWalletId?: string, returnIdentities?: boolean, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).searchTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WalletsApi - axios parameter creator
 * @export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an end user wallet.
         * @summary Create a wallet
         * @param {WalletCreationRequest} [walletCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (walletCreationRequest?: WalletCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a blockchain address
         * @param {string} walletId Identifier for the wallet.
         * @param {GenerateAddressRequest} [generateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAddress: async (walletId: string, generateAddressRequest?: GenerateAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('generateAddress', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{walletId}/addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of addresses associated with a wallet.
         * @summary List all addresses
         * @param {string} walletId Identifier for the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses: async (walletId: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAddresses', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{walletId}/addresses`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wallet
         * @param {string} walletId Identifier for the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getWallet', 'walletId', walletId)
            const localVarPath = `/v1/wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of a user\'s wallets.
         * @summary List all wallets
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets: async (from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (pageBefore !== undefined) {
                localVarQueryParameter['pageBefore'] = pageBefore;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['pageAfter'] = pageAfter;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * @export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an end user wallet.
         * @summary Create a wallet
         * @param {WalletCreationRequest} [walletCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(walletCreationRequest?: WalletCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(walletCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a blockchain address
         * @param {string} walletId Identifier for the wallet.
         * @param {GenerateAddressRequest} [generateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateAddress(walletId: string, generateAddressRequest?: GenerateAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateAddress(walletId, generateAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of addresses associated with a wallet.
         * @summary List all addresses
         * @param {string} walletId Identifier for the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddresses(walletId: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddresses(walletId, from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a wallet
         * @param {string} walletId Identifier for the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of a user\'s wallets.
         * @summary List all wallets
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallets(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallets(from, to, pageBefore, pageAfter, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WalletsApi - factory interface
 * @export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * Creates an end user wallet.
         * @summary Create a wallet
         * @param {WalletCreationRequest} [walletCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(walletCreationRequest?: WalletCreationRequest, options?: any): AxiosPromise<CreateWalletResponse> {
            return localVarFp.createWallet(walletCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
         * @summary Create a blockchain address
         * @param {string} walletId Identifier for the wallet.
         * @param {GenerateAddressRequest} [generateAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAddress(walletId: string, generateAddressRequest?: GenerateAddressRequest, options?: any): AxiosPromise<GenerateAddressResponse> {
            return localVarFp.generateAddress(walletId, generateAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of addresses associated with a wallet.
         * @summary List all addresses
         * @param {string} walletId Identifier for the wallet.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses(walletId: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetAddressesResponse> {
            return localVarFp.getAddresses(walletId, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wallet
         * @param {string} walletId Identifier for the wallet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId: string, options?: any): AxiosPromise<GetWalletResponse> {
            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of a user\'s wallets.
         * @summary List all wallets
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<GetWalletsResponse> {
            return localVarFp.getWallets(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
    /**
     * Creates an end user wallet.
     * @summary Create a wallet
     * @param {WalletCreationRequest} [walletCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public createWallet(walletCreationRequest?: WalletCreationRequest, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).createWallet(walletCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. 
     * @summary Create a blockchain address
     * @param {string} walletId Identifier for the wallet.
     * @param {GenerateAddressRequest} [generateAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public generateAddress(walletId: string, generateAddressRequest?: GenerateAddressRequest, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).generateAddress(walletId, generateAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of addresses associated with a wallet.
     * @summary List all addresses
     * @param {string} walletId Identifier for the wallet.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getAddresses(walletId: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getAddresses(walletId, from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a wallet
     * @param {string} walletId Identifier for the wallet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWallet(walletId: string, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of a user\'s wallets.
     * @summary List all wallets
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter. 
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore. 
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    public getWallets(from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) {
        return WalletsApiFp(this.configuration).getWallets(from, to, pageBefore, pageAfter, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WiresApi - axios parameter creator
 * @export
 */
export const WiresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountWireBankAccount: async (wireCreationRequest?: WireCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/wires`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wireCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWireBankAccount: async (wireCreationRequest?: WireCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/banks/wires`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wireCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountWireBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/wires/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Wire bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireBankAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/businessAccount/banks/wires`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id.
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireInstructionsBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBusinessAccountWireInstructionsBankAccount', 'id', id)
            const localVarPath = `/v1/businessAccount/banks/wires/{id}/instructions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWireBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWireBankAccount', 'id', id)
            const localVarPath = `/v1/banks/wires/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWireInstructionsBankAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWireInstructionsBankAccount', 'id', id)
            const localVarPath = `/v1/banks/wires/{id}/instructions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WiresApi - functional programming interface
 * @export
 */
export const WiresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WiresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessAccountWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBusinessAccountWireBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessAccountWireBankAccount(wireCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWireBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWireBankAccount(wireCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountWireBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountWireBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountWireBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Wire bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountWireBankAccounts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountWireBankAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountWireBankAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id.
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessAccountWireInstructionsBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessAccountWireInstructionsBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessAccountWireInstructionsBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWireBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWireBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWireBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWireInstructionsBankAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWireInstructionsBankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWireInstructionsBankAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WiresApi - factory interface
 * @export
 */
export const WiresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WiresApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessAccountWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: any): AxiosPromise<CreateBusinessAccountWireBankAccountResponse> {
            return localVarFp.createBusinessAccountWireBankAccount(wireCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Wire bank account
         * @param {WireCreationRequest} [wireCreationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: any): AxiosPromise<CreateWireBankAccountResponse> {
            return localVarFp.createWireBankAccount(wireCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountWireBankAccountResponse> {
            return localVarFp.getBusinessAccountWireBankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Wire bank accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireBankAccounts(options?: any): AxiosPromise<GetBusinessAccountWireBankAccounts200Response> {
            return localVarFp.getBusinessAccountWireBankAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id.
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessAccountWireInstructionsBankAccount(id: string, options?: any): AxiosPromise<GetBusinessAccountWireInstructionsBankAccountResponse> {
            return localVarFp.getBusinessAccountWireInstructionsBankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Wire bank account
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWireBankAccount(id: string, options?: any): AxiosPromise<GetWireBankAccountResponse> {
            return localVarFp.getWireBankAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the wire transfer instructions into the Circle bank account given your bank account id
         * @summary Get Wire instructions
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWireInstructionsBankAccount(id: string, options?: any): AxiosPromise<GetWireInstructionsBankAccountResponse> {
            return localVarFp.getWireInstructionsBankAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WiresApi - object-oriented interface
 * @export
 * @class WiresApi
 * @extends {BaseAPI}
 */
export class WiresApi extends BaseAPI {
    /**
     * 
     * @summary Create a Wire bank account
     * @param {WireCreationRequest} [wireCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public createBusinessAccountWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).createBusinessAccountWireBankAccount(wireCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Wire bank account
     * @param {WireCreationRequest} [wireCreationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public createWireBankAccount(wireCreationRequest?: WireCreationRequest, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).createWireBankAccount(wireCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Wire bank account
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public getBusinessAccountWireBankAccount(id: string, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).getBusinessAccountWireBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Wire bank accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public getBusinessAccountWireBankAccounts(options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).getBusinessAccountWireBankAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the wire transfer instructions into the Circle bank account given your bank account id.
     * @summary Get Wire instructions
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public getBusinessAccountWireInstructionsBankAccount(id: string, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).getBusinessAccountWireInstructionsBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Wire bank account
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public getWireBankAccount(id: string, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).getWireBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the wire transfer instructions into the Circle bank account given your bank account id
     * @summary Get Wire instructions
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WiresApi
     */
    public getWireInstructionsBankAccount(id: string, options?: AxiosRequestConfig) {
        return WiresApiFp(this.configuration).getWireInstructionsBankAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


